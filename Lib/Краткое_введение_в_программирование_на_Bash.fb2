<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>Гарольд</first-name>
    <last-name>Родригес </last-name>
    <nickname> </nickname>
   </author>
   <book-title>Краткое введение в программирование на Bash</book-title>
   <annotation>
    <p>Предлагаем вам познакомиться со статьей Гарольда Родригеса (Harold Rodriguez) Краткое введение в программирование на Bash</p>
    <p>«Данное введение в программирование на bash прельстило меня своей краткостью и содержательностью. В то же время я изменил несколько примеров, потому что они делали слегка не то, что ожидается новичками. Начинающим текст будет полезен как отправная точка для начала написания скриптов. Опытным — как справочник. Удачного чтения!» Антон Чернышов, переводчик.</p>
   </annotation>
   <keywords>Bash</keywords>
   <date></date>
   <coverpage>
    <image l:href="#bashcover.png"/></coverpage>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>Владимир</first-name>
    <last-name>Черный</last-name>
   </translator>
  </title-info>
  <document-info>
   <author>
    <nickname>Ivush</nickname>
    <home-page>http://anykeychhik.ru/</home-page>
    <email>ivush.n1@yandex.ru</email>
   </author>
   <program-used>FictionBook Editor Release 2.6</program-used>
   <date value="2013-01-31">31 January 2013</date>
   <id>91A31E03-ABC8-4FB0-87C7-547456957237</id>
   <version>1.02</version>
   <history>
    <p>1.02 - Ivush</p>
   </history>
  </document-info>
 </description>
 <body>
  <title>
   <p>Краткое введение в программирование на Bash </p>
  </title>
  <section>
   <title>
    <p>Часть I</p>
   </title>
   <epigraph>
    <p>Тема программирования на bash из разряда тех, которые могут быть рассмотрены и в пару, и в сотни страниц. Гарольд Родригес (Harold Rodriguez) объясняет эту тему в приведенном ниже руководстве из двух частей. Его прекрасный и яркий стиль позволил ему охватить все существенные черты программирования на bash буквально на нескольких страницах.</p>
    <p>Если вы никогда не программировали на bash ранее — сейчас самое время начать. Даже если у вас мало знаний о том, что такое bash, вы вполне можете посмотреть на множество интересных скриптов, разбираемых Гарольдом.</p>
   </epigraph>
   <section>
    <title>
     <p>Введение</p>
    </title>
    <p>Подобно остальным оболочкам, доступным в Linux, Bourne Again shell (bash) является не только, собственно, командной оболочкой, но и языком для написания сценариев (скриптов)<a l:href="#n_1" type="note">[1]</a>. Скрипты позволяют в полной мере использовать возможности оболочки и автоматизировать множество задач, которые иначе потребуют для своего выполнения ввода множества команд. Многие программы, работающие внутри вашего компьютера с Linux — это скрипты. Если вы захотите узнать, как они работают, или изменить их, важно понимать их синтаксис и семантику. Кроме того, понимая язык bash, вы сможете писать свои собственные программы, чтобы выполнять разные задачи теми способами, которые выберете сами.</p>
   </section>
   <section>
    <title>
     <p>Так все-таки программирование (programming) или написание скриптов (scripting)? </p>
    </title>
    <p>Новичков в программировании, как правило, озадачивает разница между, собственно, программированием и языками скриптов. Программы, написанные на каких-то языках программирования, обычно гораздо более мощные по возможностям и работают намного быстрее, чем программы, написанные на языках сценариев. Примеры языков программирования — C, C ++ и Java. Создание программы на каком-либо языке программирования обычно начинается с написания исходного кода (текстовый файл, содержащий инструкции о том, как будет работать окончательная программа), затем его необходимо скомпилировать (собрать) в исполняемый файл. Этот исполняемый файл не так легко переносить между различными операционными системами. Например, если вы напишете на программу на C для Linux, вы не сможете запустить ее в Windows. Чтобы сделать это, вам придется перекомпилировать исходный код под Windows. Написание скрипта также начинается с написания исходного кода, который не компилируется в исполняемый файл. Вместо этого интерпретатор оболочки последовательно читает инструкции в файле исходного кода и выполняет их. К сожалению, поскольку интерпретатор должен читать каждую инструкцию, скорость исполнения скрипта обычно медленнее<a l:href="#n_2" type="note">[2]</a>, чем у скомпилированной программы. Основным преимуществом скриптов является то, что вы можете легко переносить исходный файл в любую операционную систему и просто запускать их<a l:href="#n_3" type="note">[3]</a>.</p>
    <p>Bash — это язык сценариев. Он отлично подходит для написания небольших программ, но если вы планируете делать какие-то мощные приложения, выбор для этого какого-либо языка программирования предпочтительнее для вас. Другие примеры скриптовых языков Perl, Lisp, и Tcl.</p>
   </section>
   <section>
    <title>
     <p>Что нужно знать для написания своих скриптов?</p>
    </title>
    <p>Для этого необходимо знание основных команд Linux. Например, вы должны знать, как копировать, перемещать и создавать новые файлы. Обязательно умение использовать какой-либо текстовый редактор. Существуют три основных текстовых редактора в Linux: vi, emacs и pico<a l:href="#n_4" type="note">[4]</a>. Если вы не знакомы с vi или emacs, используйте pico или другой простой в использовании текстовый редактор.</p>
    <p><strong><emphasis>Внимание!!!</emphasis></strong></p>
    <p><emphasis>Не следует учиться программировать на bash из-под пользователя root! В противном случае — может случиться все что угодно! Я не буду нести никакой ответственности, если вы случайно допустите ошибку и испортите вашу систему. Вы предупреждены! Используйте учетную запись обычного пользователя без каких-либо привилегий. Вы можете даже создать нового пользователя только для обучения написанию сценариев. Таким образом, худшее, что произойдет в данном случае — это исчезновение данных в каталоге этого пользователя.</emphasis></p>
   </section>
   <section>
    <title>
     <p>Ваша первая программа на Bash</p>
    </title>
    <p>Нашей первой программой будет классическая «Hello World». Конечно, если уже вы программировали раньше, вы должно быть устали от таких примеров. Однако это — традиция и кто я такой, чтобы менять ее? Программа «Hello World» просто выводит слова «Hello World» на экран. Запустите текстовый редактор и наберите в нем следующее:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo "Hello World"</code></p>
    <p>Первая строка сообщает Linux использовать интерпретатор bash для запуска этого скрипта. В этом случае, bash находится в каталоге /bin. Если у вас bash находится где-то еще, сделайте соответствующие изменения в данной строке. Явное указание интерпретатора очень важно, удостоверьтесь еще раз, что указали его, поскольку данная строка говорит Linux какой именно интерпретатор нужно использовать для выполнения инструкций в скрипте. Следующее, что нужно сделать, это сохранить скрипт. Назовем егоhello.sh. После этого вам нужно сделать скрипт исполняемым:</p>
    <p><code>$ chmod u+x hello.sh</code></p>
    <p>Если вы не понимаете, что делает эта команда, прочтите справочную страницу команды chmod:</p>
    <p><code>$ man chmod</code></p>
    <p>Как только это будет сделано, вы сможете запустить программу, просто набрав ее название:</p>
    <p><code>$ ./hello.sh</code></p>
    <p><code>Hello World</code></p>
    <p>Получилось! Это ваша первая программа! И хотя она скучная и не делает ничего полезного, она показывает как именно все работает. Просто запомните эту простую последовательность действий: напишите код, сохраните файл, сделайте его исполняемым с помощьюchmodи запустите.</p>
   </section>
   <section>
    <title>
     <p>Команды, команды и команды</p>
    </title>
    <p>Что именно делает ваша первая программа? Она печатает на экран слова «Hello World». Каким образом она это делает? Она использует команды. В нашей программе мы написали только одну команду —echo «Hello World». Что именно тут команда?echo. Эта программа принимает один аргумент и печатает его на экран.</p>
    <p>Аргументом является все, что следует после ввода названия программы. В нашем случае«Hello World»это и есть аргумент, переданный команде echo. При вводе команды ls /home/, аргументом команды ls является /home. Ну и что это все означает? А означает это то, что если у вас есть программа, которая принимает какой-то аргумент и выводит что-то на экран, вы можете использовать ее вместо echo. Предположим, что у нас есть программа под названием foo. Эта программа будет принимать один аргумент (строку из слов) и печатать их на экран. Тогда мы можем переписать нашу программу вот так:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>foo "Hello World"</code></p>
    <p>Сохраните ее, сделайте исполняемой и перезапустите ее<a l:href="#n_5" type="note">[5]</a>:</p>
    <p><code>$ ./hello</code></p>
    <p><code>Hello World</code></p>
    <p>Точно такой же результат. Использовался ли тут какой-то уникальный код? Нет. Написали ли мы какую-то программу? Нет, если только вы не являетесь автором программы echo. Все, что вы сделали — просто встроили программу echoв наш скрипт и снабдили ее аргументом. Примером альтернативы использования команды echo в реальном программировании является команда printf, которая имеет больше возможностей, если вы знакомы с программированием на C. Ну и на самом деле, точно такой же результат можно было бы получить и без написания скрипта:</p>
    <p><code>$ echo "Hello World”</code></p>
    <p><code>Hello World</code></p>
    <p>Написание скриптов на bash предлагает широкий спектр возможностей и этому легко научиться. Как вы только что могли видеть, вы используете другие команды Linux, чтобы писать ваши собственные скрипты. Ваша программа-оболочка представляет собой несколько других программ, собранных вместе для выполнения какой-либо задачи.</p>
   </section>
   <section>
    <title>
     <p>Другие полезные программы</p>
    </title>
    <p>Сейчас мы напишем программу, которая переместит все файлы в каталог, удалит его вместе с содержимым, а затем создаст это каталог заново. Это может быть сделано с помощью следующих команд<a l:href="#n_6" type="note">[6]</a>:</p>
    <p><code>$ touch file1</code></p>
    <p><code>$ mkdir trash</code></p>
    <p><code>$ mv file1 trash</code></p>
    <p><code>$ rm -rf trash</code></p>
    <p><code>$ mkdir trash</code></p>
    <p>Вместо того, чтобы вводить это все в интерактивном режиме, напишем скрипт, выполняющий эти команды:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>touch file1</code></p>
    <p><code>mkdir trash</code></p>
    <p><code>mv file1 trash</code></p>
    <p><code>rm -rf trash</code></p>
    <p><code>mkdir trash</code></p>
    <p><code>echo “Файл удален!”</code></p>
    <p>Сохраните его под именем clean.sh и теперь все, что нужно сделать — это запустить его. Он переместит все файлы в каталог, удалит его, создаст его заново каталог и даже напечатает сообщение об удалении файлов. Запомните, если вы обнаружите, что регулярно делаете нечто требующее набора одной и той же последовательности команд — это вполне можно автоматизировать написанием скрипта.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Комментарии</p>
   </title>
   <section>
    <p>Комментарии помогают сделать ваш код более читабельным. Они не влияют на то, что выводит программа. Они написаны специально для того, чтобы вы их прочли. Все комментарии в Bash начинаются с хэш-символа #, за исключением первой строки (#!/bin/bash), имеющей специальное назначение. Первая строка — не комментарий. Возьмем для примера следующий код:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># Эта программа считает от 1 до 10:</code></p>
    <p><code>for i in 1 2 3 4 5 6 7 8 9 10; do</code></p>
    <p><code>echo $i</code></p>
    <p><code>done</code></p>
    <p>Даже если вы пока не понимаете скрипты на Bash, вы сразу же поймете, что делает приведенный выше пример, благодаря комментарию. Комментирование кода — хорошая практика. Со временем вы поймете, что, если вам нужно будет поддерживать ваши скрипты, то при наличии комментированного кода — делать это станет легче.</p>
   </section>
   <section>
    <title>
     <p>Переменные</p>
    </title>
    <p>Переменные это просто «контейнеры», которые содержат некоторые значения. Создавать их нужно по многим причинам. Вам нужно будет как-то сохранять вводимые пользователем данные, аргументы или числовые величины. Например:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=12</code></p>
    <p><code>echo ”Значение переменной x - $x”</code></p>
    <p>Здесь мы присвоили переменной x значение 12. Строка echo “Значение переменной х - $x”напечатает текущее значение x. При определении переменной не допускается наличие каких-то пробелов между именем переменной и оператором присваивания: «=». Синтаксис следующий:</p>
    <p>имя_переменной=ее_значение.</p>
    <p>Обращение к переменным выполняется с помощью префикса «$» перед именем переменной. Именно таким образом мы получаем доступ к значению переменной х с помощью команды echo $x.</p>
    <p>Есть два типа переменных — локальные и переменные окружения. Переменные окружения устанавливаются системой и имеют специальной назначение. Обычно их значение может быть выведено с помощью команды echo. Например, если ввести:</p>
    <p><code>$ echo $SHELL</code></p>
    <p><code>/bin/bash</code></p>
    <p>Вы получили имя оболочки, запущенной в данный момент. Переменные среды задаются в файле /etc/profile и в ~/.bash_profile. Команда echo может применяться для проверки текущего значения переменной.</p>
    <p><strong>Примечание:</strong>задание переменных среды подробно описано в этой статье — <a l:href="http://learnbyexamples.org/linux/linux-tip-how-to-set-shell-environment-variables-bash-shell.html">«Как задавать переменные среды»</a>. В статье также описаны некоторые особенности оболочки Bash.</p>
    <p>Если вы все еще возникают проблемы с пониманием того зачем нужно использовать переменные, приведем пример:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo "Значение х - 12".</code></p>
    <p><code>echo "У меня есть 12 карандашей".</code></p>
    <p><code>echo "Он сказал мне, что значение х равно 12".</code></p>
    <p><code>echo "Мне 12 лет."</code></p>
    <p><code>echo "Как получилось, что значение х равно 12?"</code></p>
    <p>Хорошо, теперь предположим, что вы решите поменять значение х на 8 вместо 12. Что для этого нужно сделать? Вы должны изменить все строки кода, в которых говорится, что х равно 12. Но погодите… Есть другие строки кода, где упоминается это число, поэтому простую автозамену использовать не получится. Теперь приведем аналогичный пример, только с использованием переменных:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=12 # задаем переменной х значение 12</code></p>
    <p><code>echo "Значение х = $х"</code></p>
    <p><code>echo "У меня есть 12 карандашей"</code></p>
    <p><code>echo "Он сказал мне, что значение х равно $х"</code></p>
    <p><code>echo "Мне 12 лет"</code></p>
    <p><code>echo "Как получилось, что значение х равно $x?"</code></p>
    <p>Здесь мы видим, что $x выводит текущее значение переменной х равное 12. Поэтому теперь, если вы хотите задать новое значение х равное 8, то все что вам нужно сделать, это изменить одну строчку с х=12 на х=8, и в выводе все строки с упоминанием x также изменяться. Поэтому вам не нужно руками модифицировать остальные строки. Как вы увидите позже, переменные имеют и другие способы применения.</p>
   </section>
   <section>
    <title>
     <p>Управляющие операторы</p>
    </title>
    <p>Управляющие операторы делают вашу программу компактнее и позволяют ей принимать решения. И, что еще более важно, они позволяют нам выполнять проверку на наличие ошибок. До сих пор все, что мы сделали, это писали скрипты, которые просто исполняют набор инструкций в файле. Например:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>cp /etc/foo .</code></p>
    <p><code>echo ”Готово”</code></p>
    <p>Это небольшой скрипт, назовем его bar.sh, копирует файл с именем /etc/foo в текущий каталог и выводит «Готово» на экране. Эта программа будет работать при одном условии — файл /etc/foo должен существовать. В противном случае вот что произойдет:</p>
    <p><code>$./bar.sh</code></p>
    <p><code>cp: /etc/foo: No such file or directory</code></p>
    <p><code>Готово</code></p>
    <p>Таким образом, как вы видите, есть проблема. Не у каждого, кто будет запускать вашу программу, будет файл/etc/foo. Наверное, было бы лучше, если б ваша программа сначала проверяла наличие данного файла, а затем при положительном ответе — выполняла бы копирование, в противном случае — просто бы завершала работу. В псевдо-коде это выглядит так:</p>
    <p><code>если /etc/foo существует, то</code></p>
    <p><code>скопировать /etc/foo в текущую директорию</code></p>
    <p><code>напечатать "Готово" на экране</code></p>
    <p><code>в противном случае,</code></p>
    <p><code>напечатать на экране "Этот файл не существует"</code></p>
    <p><code>выход</code></p>
    <p>Можно ли это сделать в Bash? Конечно! Набор управляющих операторов Bash включает в себя:if, while, until, for и case. Каждый из этих операторов является парным, то есть начинается он одним тегом и заканчивается другим. Например, если условный оператор if начинается с if и заканчивается fi. Управляющие операторы — это не отдельные программы в системе, они встроены в bash.</p>
   </section>
   <section>
    <title>
     <p>if … else … elif … fi</p>
    </title>
    <p>Это один из наиболее распространенных операторов. Он позволяет программе принимать решения следующим образом — «если условие верно — делаем одно, если нет — делаем что-то другое». Чтобы эффективно его использовать, сначала нужно научиться пользоваться командой test. Эта программа выполняет проверку условия (например, существует ли файл, есть ли необходимые права доступа). Вот переписанный вариант bar.sh:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>if test -f /etc/foo</code></p>
    <p><code>then</code></p>
    <p><code># Файл существует, копируем его и печатаем сообщение на экране</code></p>
    <p><code>cp /etc/foo .</code></p>
    <p><code>echo "Готово".</code></p>
    <p><code>else # Файл не существует, поэтому мы печатаем сообщение</code></p>
    <p><code># и завершаем работу</code></p>
    <p><code>echo "Этот файл не существует."</code></p>
    <p><code>exit</code></p>
    <p><code>fi</code></p>
    <empty-line/>
    <p>Обратите внимание на отступы строки после then и else. Они не являются обязательными, но зато делают чтение кода гораздо более простым в том смысле, что делают логику программы более наглядной. Теперь запустите программу. Если у вас есть файл /etc/foo — он будет скопирован, в противном случае будет напечатано сообщение об ошибке. Команда test проверяет существование файла. Ключ -f проверяет, является ли аргумент обычным файлом. Ниже приведен список опций test<a l:href="#n_7" type="note">[7]</a>:</p>
    <p>Ключи команды test:</p>
    <p><code>-d проверяет наличие файла и то, что он является каталогом</code></p>
    <p><code>-e проверяет существование файла</code></p>
    <p><code>-f проверяет наличие файла и то, что это обычный файл</code></p>
    <p><code>-g проверяет наличие у файла SGID-бита</code></p>
    <p><code>-r проверяет наличие файла и то, что он доступен на чтение</code></p>
    <p><code>-s проверяет наличие файла и то, что его размер больше нуля</code></p>
    <p><code>-u проверяет наличие у файла SUID-бита</code></p>
    <p><code>-w проверяет наличие файла и то, что он доступен на запись</code></p>
    <p><code>-x проверяет наличие файла и наличие у него прав на запуск</code></p>
    <p>Оператор else используется, когда вы хотите, чтобы ваша программа еще что-то делала, если первое условие не выполняется. Существует также оператор elif, который может использоваться вместо еще одного if.elif означает «else if». Он используется, когда первое условие не выполняется, и вы хотите проверить еще одно условие.</p>
    <p>Если вам не нравится приведенная форма записи if и test, есть сокращенный вариант.</p>
    <p>Например, код:</p>
    <p><code>if test -f /etc/foo</code></p>
    <p><code>then</code></p>
    <p><code>Можно записать вот так:</code></p>
    <p><code>if [ -f /etc/foo ]; then</code></p>
    <p>Квадратные скобки — это еще один вариант записи test. Если у вас есть опыт в программировании на C, этот синтаксис для вас может быть более удобным. Обратите внимание на наличие пробелов до и после каждой из скобок test<a l:href="#n_8" type="note">[8]</a>. Точка с запятой: «;» говорит оболочке о завершении одного оператора и начале следующего. Все, что находится после этого символа будет работать так, как будто он находится на отдельной строке. Это делает код более удобным для чтения и, естественно, что такая запись необязательна. Если вы предпочитаете другой вариант записи —then можно сразу поместить в другой строке.</p>
    <p>Если вы используете переменные — их нужно помещать в кавычки. Например:</p>
    <p><code>if [ "$name" -eq 5 ]; then</code></p>
    <p>оператор -eq будет объяснен далее в этой статье.</p>
   </section>
   <section>
    <title>
     <p>while … do … done</p>
    </title>
    <p>Оператор while используется для организации циклов. Он работает так «пока (while) условие истинно, делать что-то». Рассмотрим это на примере:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>while true; do</code></p>
    <p><code>echo "Нажмите CTRL-C для выхода."</code></p>
    <p><code>done</code></p>
    <p>true — это тоже программа. Единственное, что она тут делает — это запускает тело цикла снова и снова. Использование true считается медленным, потому что ваш скрипт должен запускать ее раз за разом. Можно использовать альтернативный вариант:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>while :; do</code></p>
    <p><code>echo "Нажмите CTRL-C для выхода."</code></p>
    <p><code>done</code></p>
    <p>Это позволяет добиться точно такого же эффекта, но быстрее, потому что «:» — это встроенная функция bash. Единственное отличие состоит в принесении в жертву читабельности кода. Используйте из приведенных вариантов тот, который вам нравится больше. Ниже приведен гораздо более полезный вариант использования переменных:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=0;</code></p>
    <p><code>while [ "$x" -le 10 ]; do</code></p>
    <p><code>echo "Текущее значение х: $х"</code></p>
    <p><code># Увеличиваем значение х:</code></p>
    <p><code>x=$(expr $x + 1)</code></p>
    <p><code>sleep 1</code></p>
    <p><code>done</code></p>
    <p>Здесь мы используем для проверки состояния переменной x запись с квадратными скобками. Опция -le означает «меньше или равно (less or equal)». Говоря обычным языком приведенный код говорит: «пока (while) х меньше или равен 10, выводить на экран текущее значение х, после чего добавлять к текущему значению х единицу». Оператор sleep 1 приостанавливает выполнение программы на одну секунду.</p>
    <p>Ниже приведен список возможных операций сравнения целых чисел<a l:href="#n_9" type="note">[9]</a>:</p>
    <p><code>x -eq y x = y (equal)</code></p>
    <p><code>x -ne y x не равен y (not equal)</code></p>
    <p><code>x -gt y x больше, либо равен y (greater than)</code></p>
    <p><code>x -lt y x меньше, либо равен y (lesser than)</code></p>
    <p><code>Операторы сравнения строк:</code></p>
    <p><code>x = y строка x идентична y</code></p>
    <p><code>x != y строка х не совпадает y</code></p>
    <p><code>-n x выражение истинно, если строка х ненулевой длины</code></p>
    <p><code>-z x выражение истинно, если строка х имеет нулевую длину</code></p>
    <p><code>Скрипт, приведенный выше, нетрудно понять, за исключением, может быть, только этой строки:</code></p>
    <p><code>x=$(expr $x + 1)</code></p>
    <p>Комментарий приведенный выше он говорит нам, что он увеличивает х на 1. Но что означает запись$ (...)? Это переменная? Нет. На самом деле это способ сказать оболочке, что вы хотите запустить команду expr $x + 1, и присвоить результат ее выполнения — х. Любая команда, заключенная в $ (…) будет выполняться:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>me=$(whoami)</code></p>
    <p><code>echo "Привет! Меня зовут $me"</code></p>
    <p>Попробуйте сделать приведенный пример, и вы поймете, что я имею в виду. Приведенный выше код можно было бы сократить без каких-либо потерь вот так:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo "Привет! Меня зовут $(whoami)"</code></p>
    <p>Вы сами можете выбрать, какая из записей вам ближе и понятнее. Существует и другой способ для выполнения команд или передачи результата их выполнения переменной. Как это сделать — будет объяснено позже. Пока используйте запись вида $(…).</p>
   </section>
   <section>
    <title>
     <p>until … do … done</p>
    </title>
    <p>Оператор until применяет способом аналогичным приведенному выше while. Разница лишь в том, что условие работает наоборот. Цикл while выполняет до тех пор пока условие истинно. Цикл until — до тех пор пока условие не станет истинным. Например:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=0</code></p>
    <p><code>until [ "$x" -ge 10 ]; do</code></p>
    <p><code>echo "Текущее значение х равно $ х"</code></p>
    <p><code>x=$(expr $x + 1)</code></p>
    <p><code>sleep 1</code></p>
    <p><code>done</code></p>
    <p>Эта часть кода выглядит знакомой. Попробуйте ее набрать и посмотреть, что он делает. Приведенный цикл будет работать, пока x не станет больше или равен 10. Когда величина x достигнет значения 10, цикл остановится. Таким образом, последнее значение напечатанное значение х будет 9.</p>
   </section>
   <section>
    <title>
     <p>for … in … do … done</p>
    </title>
    <p>Цикл for используется, когда вам надо перебрать несколько значений переменной. Например, вы можете написать небольшую программу, которая печатает 10 точек:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo -n "Проверка системы на наличие ошибок"</code></p>
    <p><code>for dots in 1 2 3 4 5 6 7 8 9 10; do</code></p>
    <p><code>echo -n "."</code></p>
    <p><code>done</code></p>
    <p><code>echo "Ошибок не обнаружено"</code></p>
    <p>Опция -n команды echo предотвращает автоматический перевод строки. Попробуйте один раз вариант с -n и вариант без этой опции, чтобы понять, что я имею в виду. Переменная dots последовательно принимает значения от 1 до 10 и одновременно скрипт печатает на экране точку.</p>
    <p>Приведенный дальше пример показывает, что я имею в виду под выражением «переменная последовательно принимает несколько значений»:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>for x in paper pencil pen; do</code></p>
    <p><code>echo "значение переменной х равно $х"</code></p>
    <p><code>sleep 1</code></p>
    <p><code>done</code></p>
    <p>При запуске программы, вы видите, что х сначала имеет значение «pencil», а затем она принимает значение «pen». Когда у переменной заканчивается список возможных значений, цикл завершается.</p>
    <p>Ниже приведен гораздо более полезный пример. Этот скрипт добавляет расширение .html для всех файлов в текущей директории<a l:href="#n_10" type="note">[10]</a>:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>for file in *; do</code></p>
    <p><code>echo "Добавляем расширение .html для файла $file ..."</code></p>
    <p><code>mv $file $file.html</code></p>
    <p><code>sleep 1</code></p>
    <p><code>done</code></p>
    <p>Символ * имеет специальное значение, которое в данном случае означает «все в текущем каталоге», т.е. — все файлы в каталоге. Переменная file последовательно принимает значения, соответствующие именам файлов в текущем каталоге. Затем используется программа mv для переименования файла в файл с расширением .html:</p>
   </section>
   <section>
    <title>
     <p>case … in … esac</p>
    </title>
    <p>Оператор case очень похож на if. Он отлично подходит для тех случаев, когда нужно проверить несколько условий, и вы не хотите для этого использовать несколько вложенных операторов if. Поясним на примере:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5 # инициализируем х значением 5</code></p>
    <p><code># проверяем значение х:</code></p>
    <p><code>case $x in</code></p>
    <p><code>0) echo "значение х равно 0"</code></p>
    <p><code>;;</code></p>
    <p><code>5) echo "значение х равно 5"</code></p>
    <p><code>;;</code></p>
    <p><code>9) echo "значение х равно 9"</code></p>
    <p><code>;;</code></p>
    <p><code>*) echo "значение неизвестно"</code></p>
    <p><code>;;</code></p>
    <p><code>esac</code></p>
    <p>Оператор case проверяет переменную х на равенство трем значениям. В приведенном примере, он сначала проверит, равен ли х нулю 0, затем равен ли он 5, затем равен ли он 9. И, если все проверки завершились неудачно, скрипт выведет сообщение, что значение x определить не получилось. Помните, что «*» означает «все», и в этом случае, «любое другое значение, помимо указанных явно». Если х имеет любое другое значение, отличное от 0, 5 или 9, то это значение попадает во категорию «*». При использовании сase каждое условие должно заканчиваться двумя точками с запятой.</p>
    <p>Зачем нужно использовать case, когда вы можно использовать if? Ниже приведен пример эквивалентного скрипта, написанного с использованием if. Решение о том, что быстрее написать и легче прочесть, предлагается принять самостоятельно:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5 # инициализируем х значением 5</code></p>
    <p><code>if [ "$x" -eq 0 ]; then</code></p>
    <p><code>echo "Значение х равно 0"</code></p>
    <p><code>elif [ "$x" -eq 5 ]; then</code></p>
    <p><code>echo "значение х равно 5"</code></p>
    <p><code>elif [ "$x" -eq 9 ]; then</code></p>
    <p><code>echo "значение х равно 9"</code></p>
    <p><code>else</code></p>
    <p><code>echo "Значение х определить не удалось"</code></p>
    <p><code>fi</code></p>
   </section>
   <section>
    <title>
     <p>Использование кавычек</p>
    </title>
    <p>Кавычки играют важную роль в написании скриптов оболочки. Существует три типа кавычек. Это двойные кавычки: «, одинарные ‘ (апостроф) и обратные `<a l:href="#n_11" type="note">[11]</a>. Имеет ли каждый из приведенных видов какое-то особое значение? Да.</p>
    <p><emphasis><strong>Примечание:</strong>Статья </emphasis><a l:href="http://learnbyexamples.org/linux/linux-tip-how-to-use-wildcards-quotes-back-quotes-and-apostrophes-in-shell-commands.html"><emphasis>Wildcards, Quotes, Back Quotes, Apostrophes in shell commands ( * ? [] ” ‘ ‘)</emphasis></a><emphasis> прекрасно описывает использование специальных символов. Пожалуйста, ознакомьтесь с ней в случае, если вы не знакомы с использованием этих специальных символов в скриптах оболочки. Ниже приведено краткое объяснение использования некоторых из них.</emphasis></p>
    <p>Двойные кавычки используются главным образом для объединения нескольких слов в строку и сохранения в ней пробелов. Например, «Эта строка содержит пробелы». Строка, заключенная в двойные кавычки рассматривается как единое целое. Например:</p>
    <p><code>$ mkdir hello world</code></p>
    <p><code>$ ls -F</code></p>
    <p><code>hello/ world/</code></p>
    <p>Здесь мы создали две директории. Команда mkdir принимает два слова hello и world, как два отдельных аргумента, и поэтому создает два каталога. Теперь посмотрим, а что произойдет, если написать код таким образом:</p>
    <p><code>$ mkdir “hello world”</code></p>
    <p><code>$ ls -F</code></p>
    <p><code>hello/ hello world/ world/</code></p>
    <p>Команда создала каталог с именем из двух слов. Кавычки объединили два слова в один аргумент<a l:href="#n_12" type="note">[12]</a>.</p>
    <p>Одинарные кавычки в основном используются для работы с переменными. Если переменная находится в двойных кавычках, то к ней можно обратиться через $имя_переменной. Если переменная находится в одинарных кавычках — это не возможно. Чтобы пояснить это приведем пример:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5 # задаем х равным 5</code></p>
    <p><code># используем двойные кавычки</code></p>
    <p><code>echo "Используем двойные кавычки, значение х равно $х"</code></p>
    <p><code># используем одинарные кавычки</code></p>
    <p><code>echo 'Используем одинарные кавычки, значение х равно $х'</code></p>
    <p>Почувствовали разницу? Вы можете использовать двойные кавычки, если вы не планируете использовать переменные для строки, которая в них находится. И да, если вам интересно, прямые кавычки также можно использовать для сохранения пробелов в строке тем же способом, что и двойные кавычки</p>
    <p><code>$ mkdir 'hello world'</code></p>
    <p><code>$ ls -F</code></p>
    <p><code>hello world/</code></p>
    <p>Обратные кавычки сильно отличаются от двойных и одинарных. Они не могут использоваться для сохранения пробелов. Если вы помните, выше мы использовали такую строку:</p>
    <p><code>x=$(expr $x + 1)</code></p>
    <p>Как вы уже знаете, результатом работы этой команды будет то, что выражение $х + 1 присваивается переменной x. Того же результата можно достичь и с использованием обратных кавычек:</p>
    <p><code>x='expr $x + 1&#8242;</code></p>
    <p>Какой тип кавычек лучше использовать? Тот, что вам больше нравится. Изучая скрипты вы найдете, что обратные кавычки используются чаще, чем запись $(…) . Тем не менее, я считаю, $ (…) легче читать, особенно если у вас код наподобие этого:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo “I am 'whoami'”<a l:href="#n_13" type="note">[13]</a></code></p>
    <p>Это только начало. Вы узнаете еще много чего интересного в заключительной части этой статьи<a l:href="#n_14" type="note">[14]</a>. А пока вы ее ждете - удачного вам написания скриптов...</p>
    <p><a l:href="http://learnbyexamples.org/linux/bash-programming-tutorial-1-a-quick-introduction.html">Оригинал статьи Гарольда Родригеса</a></p>
    <p>Для тех, кому невтерпеж, и кто считает, что справится с большим пособием: <a l:href="http://www.opennet.ru/docs/RUS/bash_scripting_guide/">Advanced Bash-Scripting Guide (на русском)</a></p>
   </section>
  </section>
  <section>
   <title>
    <p>Часть II</p>
   </title>
   <epigraph>
    <p>В второй статье Гарольд продолжает свое первоклассное введение в программирование на bash. На этот раз он объясняет, как выполнять арифметические операции и определять функции в bash-скриптах. Завершается статья введением в такие понятия как чтение пользовательского ввода, обработка скриптом аргументов, перехватывание сигналов и обработка кодов завершения программ.</p>
    <p>Безусловно, результаты прочтения превзойдут все ожидания! После этой статьи вас уже нельзя будет назвать новичком. Ведь вы на пути к тому, чтоб называться мастером программирования на bash!</p>
   </epigraph>
   <section>
    <title>
     <p>Арифметика и bash </p>
    </title>
    <p>Скриптовой язык bash позволяет выполнять арифметические операции. Как вы уже видели в предыдущей статье, арифметика выполняется с помощью команды expr. Однако, подобно команде true, этот вариант считается медленным. Причина кроется в том, что для использования true и expr оболочка должна предварительно запустить их. Лучше всего использовать встроенную в bash функцию, которая работает быстрее. Аналогично тому, что альтернативой true является команда":", альтернатива expr— заключение арифметического выражения в конструкцию вида$((...)). Будьте внимательны, она отличается от$(...). Отличие тут в количестве скобок. Так давайте же испробуем это:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=8 # присваиваем x значение 8</code></p>
    <p><code>y=4 # присваиваем y значение 4</code></p>
    <p><code># результат сложения x и y сохраняем в z:</code></p>
    <p><code>z=$(($x + $y))</code></p>
    <p><code>echo "Сумма $x и $y равна $z"</code></p>
    <p>Как обычно, выбор используемого метода вычислений за вами. Если использование expr для вас более комфортно и привычнее, чем $((...)), используйте его.</p>
    <p>Скриптовой язык bash умеет выполнять сложение, вычитание, умножение, целочисленное деление и получение остатка от деления. Каждое арифметическое действие имеет соответствующий ему оператор:</p>
    <table>
     <tr align="left">
      <th align="left" valign="top">Действие</th>
      <th align="left" valign="top">Оператор</th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">Сложение</td>
      <td align="left" valign="top">+</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">Вычитание</td>
      <td align="left" valign="top">-</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">Умножение</td>
      <td align="left" valign="top">*</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">Целочисленное деление</td>
      <td align="left" valign="top">/</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">Остаток от деления</td>
      <td align="left" valign="top">%</td>
     </tr>
    </table>
    <p>Большинство из вас должно быть знакомо с первыми четырьмя операциями. Если вы не знаете, что такое деление по модулю, то это просто число равное остатку от деления одного целого числа на другое. Ниже приведен пример выполнения арифметических операций в bash:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5 # устанавливаем x равным 5</code></p>
    <p><code>y=3 # устанавливаем y равным 3</code></p>
    <p><code># сохраняем сумму x и y в переменную add</code></p>
    <p><code>add=$(($x + $y))</code></p>
    <p><code># сохраняем разность x и y в переменную sub</code></p>
    <p><code>sub=$(($x – $y))</code></p>
    <p><code># умножаем x на y и сохраняем результат в переменную mul</code></p>
    <p><code>mul=$(($x * $y))</code></p>
    <p><code># в переменную div сохраняем результат деления x на y</code></p>
    <p><code>div=$(($x / $y))</code></p>
    <p><code># получаем остаток от деления x на y и сохраняем его в переменную mod</code></p>
    <p><code>mod=$(($x % $y))</code></p>
    <p><code># печатаем ответы</code></p>
    <p><code>echo "Сумма равна: $add"</code></p>
    <p><code>echo "Разность равна $sub"</code></p>
    <p><code>echo "Произведение равно $mul"</code></p>
    <p><code>echo "Результат деления $div"</code></p>
    <p><code>echo "Остаток от деления $mod"</code></p>
    <p>Код, приведенный выше, можно было бы написать с использованием expr. Например, вместо add=$(($x + $y)) мы могли бы использовать add=$(expr $x + $y)илиadd=`expr $x + $y`.</p>
   </section>
   <section>
    <title>
     <p>Чтение ввода пользователя</p>
    </title>
    <p>А теперь — самое интересное. Мы напишем свой скрипт так, что он будет взаимодействовать с пользователем, а пользователь с ним. Команда для получения данных от пользователя —read. Это встроенная в bash команда, сохраняющая ввод пользователя в указанной переменной:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># спросить у пользователя его имя и поздороваться с ним</code></p>
    <p><code>echo -n "Введите свое имя: "</code></p>
    <p><code>read user_name</code></p>
    <p><code>echo "Привет $user_name!"</code></p>
    <p>Переменная здесь — это user_name. Конечно, мы могли бы назвать ее как угодно. Оператор read прервет выполнение скрипта и будет ждать, пока пользователь введет что-нибудь и нажмет клавишу ENTER. Если клавиша ENTER была нажата без ввода чего-либо, read запустит следующую строку кода. Попробуйте это сделать. Ниже приведен тот же пример, только на этот раз мы проверяем, вводит ли пользователь что-либо:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># спрашиваем имя пользователя и выводим приветствие</code></p>
    <p><code>echo -n "Введите имя: "</code></p>
    <p><code>read user_name</code></p>
    <p><code># проверка ввода пользователя</code></p>
    <p><code>if [ -z "$user_name" ]; then</code></p>
    <p><code>echo "Вы не сказали мне свое имя!"</code></p>
    <p><code>exit</code></p>
    <p><code>fi</code></p>
    <p><code>echo "Привет $user_name!"</code></p>
    <p>В приведенном примере, если пользователь нажал ENTER и не ввел при этом ничего, наша программа напишет об этом и завершит свою работу. В противном случае она напечатает приветствие. Получение пользовательского ввода полезно для интерактивных программ, которые требуют от пользователя ввести какие-то данные.</p>
   </section>
   <section>
    <title>
     <p>Функции</p>
    </title>
    <p>Использование функций делает сопровождение своих скриптов проще. Проще говоря, это хороший способ разделить программу на более мелкие куски. Функция выполняет определенное действие и может возвращать то значение, какое вы пожелаете. Прежде чем продолжать, я приведу пример скрипта, написанного с использованием функции:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># функция hello() печатает сообщение</code></p>
    <p><code>hello(){</code></p>
    <p><code>echo "Вы находитесь в функции hello()"</code></p>
    <p><code>}</code></p>
    <p><code>echo "Вызываем функцию hello()…"</code></p>
    <p><code>hello</code></p>
    <p>Попробуйте запустить код из примера выше. Функция hello() в нем имеет только одно предназначение — просто напечатать сообщение. Но, конечно же, они могут решать и более сложные задачи. Выше мы вызвали функцию hello(), используя строку:</p>
    <p><code>hello</code></p>
    <p>Когда запускается эта строка, bash ищет скрипт для строки hello(). Он находит его в начале файла и выполняет его содержимое. Функции всегда вызываются по своему имени, что мы и видели выше. При написании функции вы можете обьявить ее, просто указав имя_функции (), как это сделано выше, или если вы хотите сделать ее объявление более явным, можете объявить ее так: function имя_функции(). Ниже представлен альтернативный способ написания функции hello()</p>
    <p><code>function hello() {</code></p>
    <p><code>echo "Вы находитесь в функции hello()"</code></p>
    <p><code>}</code></p>
    <p>После имени функции должны следовать пустые открывающая и закрывающая скобки: "()", за ними следует пара фигурных скобок: «{…}», содержащих тело функции. Другими словами, весь код функции заключен в эти фигурные скобки. Функции <strong>всегда </strong>должны быть предварительно объявлены до своего вызова. Давайте попробуем в приведенном выше примере вызвать функцию до ее объявления:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>echo "Вызов функции hello() …"</code></p>
    <p><code>hello</code></p>
    <p><code>echo "Вы вне функции hello()"</code></p>
    <p><code># функция hello() просто выводит сообщение</code></p>
    <p><code>hello(){</code></p>
    <p><code>echo "Вы находитесь в функции hello()"</code></p>
    <p><code>}</code></p>
    <p>Вот что мы получим, когда попытаемся запустить этот скрипт:</p>
    <p><code>$ ./hello.sh</code></p>
    <p><code>Вызов функции hello() ...</code></p>
    <p><code>./hello.sh: hello: command not found</code></p>
    <p><code>Вы вне функции hello()</code></p>
    <p>Как видите, мы получили сообщение об ошибке. Поэтому стоит всегда размещать ваши функции в начале кода или, по крайней мере, непосредственно перед вызовом функции.</p>
    <p>Еще один пример использования функции:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># admin.sh – инструмент для администратора</code></p>
    <p><code># функция new_user () создает новую учетную запись пользователя</code></p>
    <p><code>new_user(){</code></p>
    <p><code>echo "Подготовка к созданию новых пользователей ..."</code></p>
    <p><code>sleep 2</code></p>
    <p><code># запускаем программу adduser adduser</code></p>
    <p><code>}</code></p>
    <p><code>echo "1. Добавить пользователя"</code></p>
    <p><code>echo "2. Выход"</code></p>
    <p><code>echo "Укажите, что вы хотите сделать:"</code></p>
    <p><code>read choice</code></p>
    <p><code>case $choice in</code></p>
    <p><code>1) new_user # вызов функции new_user()</code></p>
    <p><code>;;</code></p>
    <p><code>*) exit</code></p>
    <p><code>;;</code></p>
    <p><code>esac</code></p>
    <p>Для того чтобы приведенный скрипт работал правильно, вам необходимо запустить его из-под пользователя root, т. к. иначе программа adduser не сможет создать новых пользователей. Надеюсь, этот пример (хоть он и краток) показывает положительный эффект от использования функций.</p>
   </section>
   <section>
    <title>
     <p>Перехват сигналов</p>
    </title>
    <p>Вы можете использовать встроенную в bash программу trap для перехвата сигналов в своих программах. Это хороший способ изящно завершать работу программы. Например, если пользователь, когда ваша программа работает, нажмет CTRL-C — программе будет отправлен сигнал interrupt(SIGINT), который завершит ее. Функция trap позволит вам перехватить этот сигнал, что даст возможность либо продолжить выполнение программы, либо сообщить пользователю, что программа завершает работу. Синтаксис этой команды такой:</p>
    <p><code>trap action signal</code></p>
    <p>Здесь: <emphasis>action </emphasis>— то, что вы хотите делать, когда сигнал получен; <emphasis>signal </emphasis>— сигнал, на который стоит реагировать.</p>
    <p>Список сигналов можно посмотреть с помощью команды trap -l.</p>
    <p>При указании сигналов в своих скриптах можно опустить первые три буквы названия сигнала, т. е. SIG. Например, сигнал прерывания это — SIGINT. В вашем скрипте, в качестве его имени, можно указать просто INT. Вы также можете использовать номер сигнала, указанный рядом с его именем. Например, числовое значение сигнала SIGINT — 2. Попробуйте написать и запустить приведенный ниже пример:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># использование команды trap</code></p>
    <p><code># перехватываем нажатие CTRL-C и запускаем функцию sorry()</code></p>
    <p><code>trap sorry INT</code></p>
    <p><code># функция sorry() печатает сообщение</code></p>
    <p><code>sorry(){</code></p>
    <p><code>echo "Извини меня, Дэйв. Я не могу этого сделать"</code></p>
    <p><code>sleep 3</code></p>
    <p><code>}</code></p>
    <p><code># обратный отсчет от 10 до 1:</code></p>
    <p><code>echo "Подготовка к уничтожению системы"</code></p>
    <p><code>for i in 10 9 8 7 6 5 4 3 2 1; do</code></p>
    <p><code>echo "Осталось $i секунд до уничтожения..."</code></p>
    <p><code>sleep 1</code></p>
    <p><code>done</code></p>
    <p><code>echo "Запуск программы уничтожения!"</code></p>
    <p>Наберите и запустите приведенный пример. Когда программа будет работать и вести обратный отсчет, нажмите CTRL-C. Это действие отправит программе сигнал прерывания — SIGINT. Тем не менее сигнал будет перехвачен командой trap, которая, в свою очередь, выполнит функцию sorry(). Вы можете заставить trap игнорировать сигнал, указав символ кавычек вместо указания действия. Также вы можете отключить ловушку с помощью тире: "-". Например:</p>
    <p><code># запускать функцию sorry(), если получен сигнал SIGINT</code></p>
    <p><code>trap sorry INT</code></p>
    <p><code># отключение ловушки</code></p>
    <p><code>trap - INT</code></p>
    <p><code># ничего не делать при получении сигнала</code></p>
    <p><code>SIGINT trap " INT</code></p>
    <p>Если вы отключаете ловушку, программа работает как обычно — при получении сигнала прерывается ее исполнение и она завершает работу. Когда вы говорите trap ничего не делать при получении сигнала — она делает именно это. Ничего. Программа будет продолжать работать, игнорируя сигнал.</p>
   </section>
   <section>
    <title>
     <p>Логические И и ИЛИ</p>
    </title>
    <p>Вы уже видели, что такое управляющие структуры и как их использовать. Для решения тех же задач есть еще два способа. Это логическое И — "&amp;&amp;" и логическое "ИЛИ" — « || ». Логическое И используется следующим образом:</p>
    <p><emphasis>выражение_1</emphasis>&amp;&amp;<emphasis>выражение_2</emphasis></p>
    <p>Сначала выполняется выражение, стоящее слева, если оно истинно, выполняется выражение, стоящее справа. Если <emphasis>выражение_1 </emphasis>возвращает ЛОЖЬ, то <emphasis>выражение_2 </emphasis>не будет выполнено. Если оба выражения возвращают ИСТИНУ, выполняется следующий набор команд. Если какое-либо из выражений не истинно, приведенное выражение считает ложным в целом. Другими словами, все работает так:</p>
    <p><emphasis>если выражение_1 истинно И выражение_2 истинно, тогда выполнять…<a l:href="#n_15" type="note">[15]</a></emphasis></p>
    <p>Пример использования:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5</code></p>
    <p><code>y=10</code></p>
    <p><code>if [ "$x" -eq 5 ] &amp;&amp; [ "$y" -eq 10 ]; then</code></p>
    <p><code>echo "Оба условия верны"</code></p>
    <p><code>else</code></p>
    <p><code>echo "Условия не верны"</code></p>
    <p><code>fi</code></p>
    <p>Здесь мы находим, что переменные х и у содержат именно те значения, которые мы проверяем, поэтому проверяемые условия верны. Если вы измените значение с х = 5 на х = 12, а затем снова запустите программу, она выдаст фразу «Условия не верны».</p>
    <p>Логическое ИЛИ используется аналогичным образом. Разница лишь в том, что оно проверяет ошибочность выражения слева. Если это так — оно начинает выполнять следующий оператор:</p>
    <p><code><emphasis>выражение_1</emphasis>||<emphasis>выражение_2</emphasis></code></p>
    <p>Данное выражение в псевдокоде выглядит так:</p>
    <p><emphasis><code><emphasis>если выражение_1 истинно ИЛИ выражение_2 истинно, выполняем …</emphasis></code></emphasis></p>
    <p>Таким образом, любой последующий код будет выполняться, если хотя бы одно из выражений истинно:</p>
    <empty-line/>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=3</code></p>
    <p><code>y=2</code></p>
    <p><code>if [ "$x" -eq 5 ] || [ "$y" -eq 2 ]; then</code></p>
    <p><code>echo "Одно из условий истинно"</code></p>
    <p><code>else</code></p>
    <p><code>echo "Ни одно из условий не является истинным"</code></p>
    <p><code>fi</code></p>
    <p>Здесь вы видите, что только одно из выражений истинно. Попробуйте изменить значение у и повторно запустите программу. Вы увидите сообщение, что ни одно из выражений не является истинным.</p>
    <p>Аналогичная реализация условия с помощью оператора if будет большего размера, чем вариант с использованием логического И и ИЛИ, поскольку потребует дополнительного вложенного if. Ниже приведен код, реализующий тот же функционал, но с использованием оператора if:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>x=5</code></p>
    <p><code>y=10</code></p>
    <p><code>if [ "$x" -eq 5 ]; then</code></p>
    <p><code>if [ "$y" -eq 10 ]; then</code></p>
    <p><code>echo "Оба условия верны"</code></p>
    <p><code>else</code></p>
    <p><code>echo "Оба условия неверны"</code></p>
    <p><code>fi</code></p>
    <p><code>fi</code></p>
    <p>Приведенный код менее нагляден для чтения и требует для своего написания больших усилий. Но у вас остается возможность для избавления себя от всех этих трудностей путем использования операторов логических И и ИЛИ.</p>
   </section>
   <section>
    <title>
     <p>Использование аргументов</p>
    </title>
    <p>Возможно, вы уже заметили, что большинство программ в Linux не интерактивны. Вы должны указать им какие-то параметры, в противном случае вы получите сообщение со списком возможных аргументов. Возьмем, к примеру, команду more. Если вы не укажете имя файла, она выдаст краткую справку по использованию программы. Ну и конечно же возможно сделать так, чтобы ваши скрипты также могли принимать аргументы. Для этого вам нужно знать что такое переменная вида $#. В ней содержится общее количество аргументов, переданных программе. Например, если вы запустите программу foo следующим образом:</p>
    <p><code>$ foo<emphasis>параметр</emphasis></code></p>
    <p>то значение переменной $# будет равно единице, потому что программе передан только один аргумент. Для двух аргументов ее значение будет равно двум и так далее. Также стоит знать о том, что каждый параметр командной строки (включая даже имя скрипта!!!) может также сохраняться в соответствующие переменные. Так, имя нашей программы foo будет сохранено в переменной $0. Аргумент программы <emphasis>параметр </emphasis>сохранится в переменной $1. Вы можете использовать до 9 переменных, начиная с $0 (обозначающего имя скрипта), а затем $1-$9, обозначающие аргументы программы. Давайте посмотрим, как это работает:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># скрипт, печатающий свои аргументы</code></p>
    <p><code># проверяем, переданы ли скрипту аргументы:</code></p>
    <p><code>if [ "$#" -ne 1 ]; then</code></p>
    <p><code>echo "корректный запуск программы: $0 &lt;параметр&gt;"</code></p>
    <p><code>fi</code></p>
    <p><code>echo "Переданный параметр - $1"</code></p>
    <p>Приведенный скрипт ожидает один и только один аргумент для своего запуска. Если вы не укажете ему аргументов — будет выводиться справочная информация. В противном случае, если при запуске указан какой-то аргумент — он передается в наш скрипт, который выведет его на экран. Напоминаю, что $0 это имя скрипта. Именно поэтому эта переменная используется в справочном сообщении. Последняя строка выводит переданный программе параметр — $1.</p>
   </section>
   <section>
    <title>
     <p>Работа с временными файлами</p>
    </title>
    <p>Довольно часто вам будет необходимо создавать временные файлы. Обычно это файл, в котором хранятся какие-то используемые скриптом данные либо что-то еще. Как только работа скрипта будет завершена, этот файл нужно удалить. При создании такого файла вы должны задать его имя. Проблема тут кроется в том, что файл, создаваемый вами, не должен случайно переписать уже существующий в той же директории, если их имена совпадут. Для того чтобы создать временный файл с гарантированно уникальным именем, вам нужно использовать символ «$$» символ, либо как префикс, либо как суффикс к имени создаваемого файла. Предположим, вы хотите создать временный файл с именем hello. Возможно, что у пользователя, который работает с нашим скриптом, уже есть файл с таким именем. Создавая файл с именем hello.$$ или $$hello, вы создадите файл с уникальным именем. Например:</p>
    <p><code>$ touch hello</code></p>
    <p><code>$ ls</code></p>
    <p><code>hello</code></p>
    <p><code>$ touch hello.$$</code></p>
    <p><code>$ ls</code></p>
    <p><code>hello hello.689</code></p>
    <p>Примерно так и будет выглядеть имя вашего временного файла<a l:href="#n_16" type="note">[16]</a>.</p>
   </section>
   <section>
    <title>
     <p>Коды завершения программ</p>
    </title>
    <p>Большинство программ возвращают в операционную систему какое-то число, показывающее, насколько удачно программа завершила свою работу. Например, man-страница grep говорит, что grep вернет 0, если заданный шаблон найден, и 1, если совпадений не найдено. Почему нас так волнуют эти коды завершения? По разным причинам. Допустим, мы хотим проверить — есть ли пользователь с данным именем в системе? Один из способов сделать — использовать команду вида: grep <emphasis>имя_пользователя</emphasis>/etc/passwd. Допустим, имя пользователя — vasya:</p>
    <p><code>$ grep vasya /etc/passwd</code></p>
    <p><code>$</code></p>
    <p>Ничего не вывелось. Это означает, что grep не обнаружила заданного пользователя. Но для нас было бы значительно лучше получить сообщение об этом. Это как раз тот случай, когда нужно использовать код завершения программы. Он сохраняется в переменной с именем $?. Посмотрим на следующий фрагмент кода:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code># ищем пользователя vasya в /etc/passwd,</code></p>
    <p><code># весь вывод перенаправляем в /dev/null</code></p>
    <p><code>grep vasya /etc/passwd &gt; /dev/null 2&gt;&amp;1</code></p>
    <p><code># смотрим код завершения и действуем по обстоятельствам:</code></p>
    <p><code>if [ "$? -eq 0 ]; then</code></p>
    <p><code>echo "Пользователь vasya найден"</code></p>
    <p><code>exit</code></p>
    <p><code>else</code></p>
    <p><code>echo "Пользователь vasya не найден"</code></p>
    <p><code>fi</code></p>
    <p>Теперь, когда вы запустите скрипт, он будет перехватывать и анализировать код завершения grep. Если он равен 0, значит пользователь найден и мы выводим соответствующее сообщение об ошибке. В противном случае скрипт напечатает, что пользователя найти не получилось. Это очень простой способ использования получаемого кода завершения программы. По мере практики вы сами будете понимать, для решения какой задачи вам нужно использовать эти коды завершения.</p>
    <p>Если вас озадачивает конструкция вида 2&gt;&amp;1, тут все довольно просто. В Linux этими числами обозначаются дескрипторы файлов. 0 — стандартный ввод (по умолчанию, клавиатура), 1 стандартный вывод (по умолчанию, монитор) и 2 — стандартный вывод ошибок (по умолчанию, монитор). Весь вывод команды идет в файл с дескриптором 1, любые ошибки отправляются в файл с дескриптором 2. Если вы не хотите, чтобы сообщения об ошибках появлялись на экране, просто перенаправьте его в /dev/null. Но это не прекратит вывод на экран обычной информации. Например, если у вас нет разрешения на чтение домашнего каталога другого пользователя, вы не сможете просмотреть список его содержимого:</p>
    <p><code>$ ls /root</code></p>
    <p><code>ls: /root: Permission denied</code></p>
    <p><code>$ ls /root 2&gt; /dev/null</code></p>
    <p><code>$</code></p>
    <p>Как видите, во второй раз информация об ошибке не была напечатана. Все то же самое относится к другим программам и дескриптору 1. Если вы не хотите видеть нормальный выход из программы, то есть хотите, чтобы она работала молча, вы можете перенаправить в/dev/nullи его. Теперь, если вы не хотите видеть вообще никакого вывода программы — добавьте в нее следующее:</p>
    <p><code>$ ls /root &gt; /dev/null 2&gt;&amp;1</code></p>
    <p>Это означает, что программа будет отправлять свой вывод и ошибки, которые возникают в /dev/null, т. е. будет работать молча, что нам и нужно<a l:href="#n_17" type="note">[17]</a>.</p>
    <p>А что если вы хотите, чтобы ваш скрипт тоже возвращал какой-нибудь код завершения при выходе? Команда exit может принимать один аргумент — тот самый код завершения. Обычно число 0 используется для обозначения успешного завершения работы. Число, отличное от нуля означает, что произошла какая-то ошибка. Какое число возвращать — решает сам програмист. Посмотрим приведенный пример:</p>
    <p><code>#!/bin/bash</code></p>
    <p><code>if [ -f "/etc/passwd" ]; then</code></p>
    <p><code>echo «Файл passwd существует»</code></p>
    <p><code>exit 0</code></p>
    <p><code>else</code></p>
    <p><code>echo «Нет такого файла»</code></p>
    <p><code>exit 1</code></p>
    <p><code>fi</code></p>
    <p>Задавая значение кода завершения, вы делаете возможным для других скриптов, использующих ваш скрипт, анализировать результаты его работы.</p>
   </section>
   <section>
    <title>
     <p>Переносимость ваших скриптов на bash</p>
    </title>
    <p>При написании ваших собственных скриптов важно делать это так, чтобы они оставались переносимыми. Термин «переносимость» означает, что если ваш скрипт работает под Linux, то он должен работать в другой Unix-системе с малыми изменениями или вообще без них. Чтобы добиться этого, вы должны быть осторожны при вызове внешних программ. Разработчик должен при этом ответить на вопрос: "Будет ли эта программа доступна на другом варианте Unix?"<a l:href="#n_18" type="note">[18]</a>.</p>
    <p>Допустим, вы используете программу foo, которая на Linux работает аналогично echo, поэтому вместо echo вы используете ее. Но если ваш скрипт будет работать на других системах, где нет программы foo, он начнет выдавать сообщения об ошибках. Кроме того, имейте в виду, что разные версии bash могут иметь разные методы для одних и тех же операций.</p>
    <p>Например, конструкция VAR = $(ps) делает то же самое, что и VAR = `ps`, но на самом деле старые версии оболочек, например Bourne shell (sh), признают только последний синтаксис. Если вы собираетесь распространять свои скрипты, обязательно включайте текстовый файл README, который будет предупреждать пользователя о любых сюрпризах, в том числе и о том, что скрипт проверялся на такой-то версии bash. Желательно также указать, какие программы и библиотеки (и каких версий) будут нужны скрипту<a l:href="#n_19" type="note">[19]</a>.</p>
   </section>
   <section>
    <title>
     <p>Заключение</p>
    </title>
    <p>Пришла пора завершить это краткое введение в написание скриптов на bash. Однако ваше обучение этому умению еще не завершено. В тоже время, написанного вполне достаточно, чтобы вы могли модифицировать имеющиеся скрипты и писать собственные.</p>
    <p>Если вы действительно хотите стать мастером написания скриптов на bash, я рекомендую приобрести книгу «Learning the bash shell» (Изучение оболочки bash), 2-е издание издательства O’Reilly &amp; Associates, Inc<a l:href="#n_20" type="note">[20]</a>. Скрипты на bash идеально подходят для повседневной работы по администрированию. Но если вы планируете что-то более серьезное, следует использовать гораздо более мощный язык, такой как C или Perl.</p>
   </section>
  </section>
 </body>
 <body name="notes">
  <title>
   <p>Примечания</p>
  </title>
  <section id="n_1">
   <title>
    <p>1</p>
   </title>
   <p>слова «сценарий» и «скрипт» обычно являются синонимами (прим. перев).</p>
  </section>
  <section id="n_2">
   <title>
    <p>2</p>
   </title>
   <p>намного медленнее (прим. перев)</p>
  </section>
  <section id="n_3">
   <title>
    <p>3</p>
   </title>
   <p>естественно при наличии интерпретатора для этой операционной системы (прим. перев)</p>
  </section>
  <section id="n_4">
   <title>
    <p>4</p>
   </title>
   <p>автор еще забыл nano, который лучше всего подходит начинающим, если не учитывать еще и mcedit. (прим. перев.)</p>
  </section>
  <section id="n_5">
   <title>
    <p>5</p>
   </title>
   <p>для новичков - этот пример работать не будет. (прим. перев.)</p>
  </section>
  <section id="n_6">
   <title>
    <p>6</p>
   </title>
   <p>В примере, приведенном в оригинале автор показывает, что не зря рекомендовал делать приведенные упражнения под специально созданным пользователем. Результатом выполнения данной последовательности команд будет чистый каталог, в котором вы работаете. Скорее всего это будет ваша домашняя директория. Поэтому, если вы НЕ хотите удаления всех файлов в ней - НЕ выполняйте команды из оригинала статьи. А лучше последуйте совету автора и создайте отдельного пользователя специально для тренировки написания скриптов. Этот пример я немного расширил и теперь он не такой опасный. (прим. перев.)</p>
  </section>
  <section id="n_7">
   <title>
    <p>7</p>
   </title>
   <p>Не стоит пытаться запомнить их все, т.к. это все равно нереально. Его всегда можно посмотреть в руководстве команды test - man test. (Прим. перев.)</p>
  </section>
  <section id="n_8">
   <title>
    <p>8</p>
   </title>
   <p>Наличие пробелов объясняется просто: открывающая квадратная скобка - это команда оболочки. В этом можно легко убедиться набрав в консоли команду which [ . А раз это отдельная команда, то ее нужно отделить пробелами от остальных опций. (прим. перев.)</p>
  </section>
  <section id="n_9">
   <title>
    <p>9</p>
   </title>
   <p>Полный список приведен в man test. (прим. перев.)</p>
  </section>
  <section id="n_10">
   <title>
    <p>10</p>
   </title>
   <p>Этот скрипт реально так поступает и вам возможно это не нужно. Поэтому все-таки создайте отдельного пользователя, если вы еще до сих пор этого не сделали, и экспериментируйте под ним. (прим. перев.)</p>
  </section>
  <section id="n_11">
   <title>
    <p>11</p>
   </title>
   <p>находятся слева от клавиши 1. (прим. перев.)</p>
  </section>
  <section id="n_12">
   <title>
    <p>12</p>
   </title>
   <p>Главным образом, дело в том, что bash воспринимает пробел как разделитель всего, что только можно - опций, аргументов, отдельных команд. Внутри двойных кавычек пробел теряет свое специальное значение. (прим. перев.)</p>
  </section>
  <section id="n_13">
   <title>
    <p>13</p>
   </title>
   <p>На мой взгляд, лучше использовать именно запись типа $(...), потому что запись в обратных кавычках и одинарных можно легко перепутать при наборе кода и при его чтении. (прим. перев.)</p>
  </section>
  <section id="n_14">
   <title>
    <p>14</p>
   </title>
   <p>надеюсь со временем, как только текст появится, осилить и его перевод. (прим. перев.)</p>
  </section>
  <section id="n_15">
   <title>
    <p>15</p>
   </title>
   <p>При работе с булевыми переменными ИСТИНА и ЛОЖЬ (True и False), bash ведет себя отлично от других языков программирования. В других языках 0 соответствует False (Ложь), а 1 — True (Истина). В bash все наоборот. Связано это с такой вещью, как коды завершения программ (см. ниже).</p>
  </section>
  <section id="n_16">
   <title>
    <p>16</p>
   </title>
   <p>В переменной $$ обычно хранится следующий свободный PID. Именно поэтому использование такой переменной гарантирует уникальные имена для вновь создаваемых файлов.(Примечание переводчика)</p>
  </section>
  <section id="n_17">
   <title>
    <p>17</p>
   </title>
   <p>На самом деле все работает так: Конструкция вида 2&gt;&amp;1 перенаправляет вывод ошибок (дескриптор 2) на стандартный вывод (дескриптор 1). Знак «загогулины» — &amp; — тут нужен для того, чтобы пояснить bash, что вы имеете в виду не файл с именем 1, а именно файл с дескриптором 1, т. е. стандартный вывод. Если вы укажете что-то вроде:</p>
   <p><code>$ команда 2&gt;1</code></p>
   <p>то стандартный вывод ошибок пойдет в файл с именем 1. Конструкцией 2&gt;&amp;1 мы «сцепляем» вывод команды и вывод ошибок вместе. А первым перенаправлением (первым символом &gt; в коментируемой команде) мы отправляем весь вывод команды в /dev/null. Чтобы дополнительно понять, как все работает, можете поэкспериментировать, убрав 2&gt;&amp;1 из команды и перезапустив ее.<emphasis>(Примечание переводчика)</emphasis></p>
  </section>
  <section id="n_18">
   <title>
    <p>18</p>
   </title>
   <p>И что более важно, будет ли она там работать также, как на вашей Linux системе. (Примечание переводчика)</p>
  </section>
  <section id="n_19">
   <title>
    <p>19</p>
   </title>
   <p>Для проверки наличия в скрипте команд и функций специфичных для bash в ALT Linux есть пакет <a l:href="http://prometheus.altlinux.org/en/srpm/Sisyphus/checkbashisms">checkbashisms</a>, который взят из пакета devscripts Debian.(Примечание переводчика)</p>
  </section>
  <section id="n_20">
   <title>
    <p>20</p>
   </title>
   <p>Очень полезно также <a l:href="http://www.opennet.ru/docs/RUS/bash_scripting_guide/">on-line руководство Advanced Bash-Scripting Guide</a> (Примечание редактора)</p>
  </section>
 </body>
 <binary id="bashcover.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAPAAAAFACAMAAAC1NgFhAAAAAXNSR0IArs4c6QAAAARnQU1B
AACxjwv8YQUAAAMAUExURQAAAAkGAAwIAgwMDA0NEBEGARMMARwLARgNCBYQAhMQDhkSAhQU
FBsbGyENASgPASAXAyQaAywRASkdAyAeHi0bFDMTAjUbCzkWATsYAzwcCC0gAzUmBDcoBDgn
BDopBTovFyMjIycoKC0nIysrKzUpITUyLjQ0NDo6OkQaAUodA0EuBUwjDUYoFEQwBUo1Bkw5
BlQgAVQjClsjA1QuGFI6BlM7CFg+Blg/CE09OGMmA2coAmopA2c2GHItA3wwA1xCBl5DCEBA
P1lDNGBEB2JGCGVJCGhKB2pMCG9RCXBPCXJSCXtWCn1aCnxOM0JCQkhHR0hJR0tLS1FQT1NT
U1lWVFtbW2FfX2BgX2NjY21tbXR0dHl4d3t7e4EyA4A0D4s1BI44BYs5CJQ6A5w9A50/CKE/
BIFcCoVgCotjC45oC5NqC5ptDJdxDJpxDIRmIqRBBK1EA7JFBbNIBLNJCbtLBLtMCL9QBqJ0
DaV4Dah2Dat7DbF/DYVsYYB/f8NMA8VQBc1RBcpTCNNTBdxWBd1YBeFXBeRbBuBfD+xdBfJe
BfRgBv1iBv1jCvxpEv1yHf9yIf55K/x+NLWBDryFDruJDreDEL2GELqKEMSMDsGMEMmOEMWR
D8yTDsOQEMyTENGVD9WYD9GWENSaENucEcWbOdygEv+CO+WkEuaoEeilEuuqEvOtE/WyE/a0
Gf61FP63Gvu6FP64G/6+MNyASN6FUsWhUd2zTv6JRP6MSf6SVP2fa/6mcv7DRf7HS/7OZv/P
aPrSZoODg4qEgYiHiIiIh4uLi4+QkJWOkJSUlJiYl5ubm6Ghn7OrlqOjo6mmo6mpqa6wr7Oz
s7e3uLy8vP6yhvy3jf7Bnv7ZiP3Fof7NrvXMs8TExMvLy9DPztDQz9PT09jY19vb2/7Zwv7d
yP3iz/7l1f7q3f7z2uTk5Ojo5+rq6v3t4/Tw7f304v3z7PT09Pf49/728fj3+Pn59vr6+vv9
+/v8/P37+v38+v7+/gAAAAAAAAAAAAAAAAAAAKo//XwAAAAJcEhZcwAADsMAAA7DAcdvqGQA
AAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAIddJREFUeF7tXX2YG8dZ
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</binary>
</FictionBook>
