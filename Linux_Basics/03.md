# 3. Раскрытие команд командной оболочкой

## Содержание

+ [3.1 Команды и аргументы](#31-команды-и-аргументы)
+ [3.2 Операторы управления](#32-операторы-управления)
+ [3.3 Переменные командной оболочки](#33-переменные-командной-оболочки)
+ [3.4 Встраивание и параметры командных оболочек](#34-встраивание-и-параметры-командных-оболочек)
+ [3.5 История команд командной оболочки](#35-история-команд-командной-оболочки)
+ [3.6 Формирование списков имен файлов на основе шаблонов](#36-формирование-списков-имен-файлов-на-основе-шаблонов)

[Оглавление](./README.md)

## 3.1 Команды и аргументы

### Глава 10. Команды и аргументы

В данной главе вашему вниманию представляется обзор механизма раскрытия команд командной оболочки (`shell expansion`), созданный в ходе подробного рассмотрения методик обработки команд и аргументов. Понимание принципа работы механизма раскрытия команд командной оболочки является важным ввиду того, что многие команды в вашей системе Linux подвергаются обработке и с высокой вероятностью последующей модификации средствами командной оболочки перед исполнением.

Интерфейс командной строки системы или командная оболочка, используемая в большинстве систем Linux, носит имя `bash`, которое расшифровывается как `Bourne again shell` (название "`Born again shell`" - "возрожденная командная оболочка" было изменено с целью упоминания автора оригинальной командной оболочки `sh` Стивена Борна). Командная оболочка `bash` реализует возможности командных оболочек `sh` (оригинальная командная оболочка Стивена Борна), `csh` (командная оболочка Билла Джоя с поддержкой сценариев, синтаксис которых основан на синтаксисе языка программирования C), а также `ksh` (командная оболочка Дэвида Корна).

В данной главе для демонстрации возможностей командной оболочки будет периодически использоваться команда `echo`. Команда `echo` является достаточно простой командой: она всего лишь осуществляет вывод переданных ей данных.

```sh
paul@laika:~$ echo Burtonville
Burtonville
paul@laika:~$ echo Smurfs are blue
Smurfs are blue
```

### Аргументы

Одной из важнейших возможностей командной оболочки является возможность обработки строк команд. При вводе команды после приглашения командной оболочки и нажатии клавиши `Enter` командная оболочка приступает к обработке строки команды, разделяя ее на аргументы. При обработке строки команды командная оболочка может внести множество изменений в переданные вами аргументы.

Данный процесс называется раскрытием команд командной оболочки. После того, как командная оболочка заканчивает обработку и модификацию переданной строки команды, будет осуществляться непосредственное исполнение результирующей команды.

### Удаление пробелов

Части строки команды, которые разделены с помощью одного или нескольких последовательно расположенных символов пробелов (или табуляции), рассматриваются как отдельные аргументы, причем все пробелы удаляются. Первым аргументом является сама команда, которая должна быть исполнена, остальные аргументы передаются этой команде. Фактически командная оболочка производит разделение вашей строки команды на один или несколько аргументов.

Это полностью объясняет эквивалентность следующих четырех команд после их раскрытия средствами командной оболочки.

```sh
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
```

Команда `echo` будет выводить каждый из принятых от командной оболочки аргументов. Также команда `echo` осуществляет добавление пробелов между всеми принятыми аргументами.

### Одинарные кавычки

Вы можете предотвратить удаление пробелов из строки команды, поместив ее в одинарные кавычки. Содержимое экранированной таким образом строки рассматривается как единый аргумент. В примере ниже команда echo принимает только один аргумент.

```sh
[paul@RHEL4b ~]$ echo 'Строка с      одинарными    кавычками'
Строка с      одинарными    кавычками
[paul@RHEL4b ~]$
```

### Двойные кавычки

Вы также можете предотвратить удаление пробелов из строки команды, поместив ее в двойные кавычки. Как и в примере выше, команда `echo` примет только один аргумент.

```sh
[paul@RHEL4b ~]$ echo "Строка с      двойными    кавычками"
Строка с      двойными    кавычками
[paul@RHEL4b ~]$
```

Позднее при обсуждении переменных в рамках данной книги мы разберемся с важными различиями между одинарными и двойными кавычками.

### Команда echo и кавычки

Строки, помещенные в кавычки, могут содержать специальные обозначения символов, идентифицируемые командной `echo` (в случае использования команды `echo -e`). В примере ниже продемонстрирована методика использования обозначения символа `\n` для вставки символа переноса строки, а также обозначения символа `\t` для вставки символа табуляции (обычно эквивалентного восьми символам пробела).

```sh
[paul@RHEL4b ~]$ echo -e "Строка с \nсимволом переноса строки"
Строка с 
символом переноса строки
[paul@RHEL4b ~]$ echo -e 'Строка с \nсимволом переноса строки'
Строка с 
символом переноса строки
[paul@RHEL4b ~]$ echo -e "Строка с \tсимволом табуляции"
Строка с     символом табуляции
[paul@RHEL4b ~]$ echo -e ' Строка с \tсимволом табуляции'
Строка с     символом табуляции
[paul@RHEL4b ~]$
```

Команда `echo` может генерировать и другие символы помимо символов пробелов, табуляции и переноса строки. Обратитесь к странице руководства для ознакомления со списком допустимых обозначений символов.

### Команды

#### Внешние или встроенные команды?

Не все исполняемые командной оболочкой команды являются внешними; некоторые из них являются встроенными. Внешние команды реализованы в форме программ, представленных отдельными бинарными файлами, которые размещены в какой-либо директории файловой системы. Многие бинарные файлы, реализующие функции внешних команд, размещаются в директории `/bin` или `/sbin`. Встроенные команды являются неотъемлемой частью самого приложения командной оболочки.

#### Команда `type`

Для установления того, будет ли переданная командной оболочке команда исполнена как внешняя команда или как встроенная команда, следует использовать специальную команду `type`.

```sh
paul@laika:~$ type cd
cd is a shell builtin
paul@laika:~$ type cat
cat is /bin/cat
```

Как вы можете заметить, команда cd является встроенной, а команда `cat` - внешней.

Также вы можете использовать данную команду для установления того, является ли введенная команда псевдонимом команды.

```sh
paul@laika:~$ type ls
ls is aliased to `ls --color=auto'
```

#### Исполнение внешних команд

Некоторые команды имеют как встроенные, так и внешние реализации. В случае исполнения одной из таких команд приоритет отдается встроенной реализации. Для исполнения внешней реализации вам придется ввести полный путь к бинарному файлу, являющемуся реализацией данной команды.

```sh
paul@laika:~$ type -a echo
echo is a shell builtin
echo is /bin/echo
paul@laika:~$ /bin/echo Исполнение внешней реализации команды echo...
Исполнение внешней реализации команды echo...
```

#### Команда `which`

Команда `which` осуществляет поиск бинарных файлов в директории, заданной с помощью переменной окружения `$PATH` (переменные будут рассматриваться позднее). В примере ниже устанавливается, что `cd` является встроенной командой, а `ls`, `cp`, `rm`, `mv`, `mkdir`, `pwd` и `which` - внешними командами.

```sh
[root@RHEL4b ~]# which cp ls cd mkdir pwd 
/bin/cp
/bin/ls
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:...)
/bin/mkdir
/bin/pwd
```

### Псевдонимы команд

#### Создание псевдонима команды

Командная оболочка позволяет вам создавать псевдонимы команд (`aliases`). Псевдонимы команд обычно используются для создания лучше запоминающихся имен для существующих команд или для упрощения передачи параметров команд.

```sh
[paul@RHELv4u3 ~]$ cat count.txt 
один
два
три
[paul@RHELv4u3 ~]$ alias dog=tac
[paul@RHELv4u3 ~]$ dog count.txt 
три
два
один
```

#### Сокращения команд

Команда создания псевдонима команды (`alias`) также может оказаться полезной в случае необходимости сокращения длины имени существующей команды.

```sh
paul@laika:~$ alias ll='ls -lh --color=auto'
paul@laika:~$ alias c='clear'
paul@laika:~$
```

#### Стандартные параметры команд

Псевдонимы команд могут использоваться для передачи командам стандартных параметров. Например, ниже показана методика передачи параметра -i по умолчанию при вводе команды `rm`.

```sh
[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: удалить обычный файл "winter.txt"? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: невозможно получить доступ к winter.txt: Нет такого файла или каталога
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm:удалить пустой обычный файл "winter.txt"? no
[paul@RHELv4u3 ~]$
```

В некоторых дистрибутивах используются стандартные псевдонимы команд для защиты пользователей от случайного удаления файлов ('`rm -i`', '`mv -i`', '`cp -i`').

#### Просмотр объявлений псевдонимов команд

Вы можете передать один или несколько псевдонимов команд в качестве аргументов команды `alias` для вывода их объявлений. Исполнение команды без аргументов приведет к выводу полного списка используемых на данный момент псевдонимов.

```sh
paul@laika:~$ alias c ll
alias c='clear'
alias ll='ls -lh --color=auto'
```

#### Команда `unalias`

Также вы можете прекратить использование псевдонима команды, воспользовавшись командой `unalias`.

```sh
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$
```

### Вывод информации о раскрытии команд командной оболочкой

Вы можете активировать режим вывода информации о раскрытии команд командной оболочкой с помощью команды `set -x` и остановить вывод этой информации с помощью команды `set +x`. У вас может возникнуть потребность в использовании данной возможности как при изучении данного курса, так и в случаях, когда возникают сомнения насчет того, как командная оболочка обрабатывает переданную вами команду.

```sh
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo $USER
paul
```

---
[Содержание](#содержание)

## 3.2 Операторы управления

### Глава 11. Операторы управления

В данной главе мы будем учиться размещать более одной команды в командной строке, используя для этого операторы управления. Также мы кратко обсудим связанные с этими операторами параметры (`$?`) и вопросы использования аналогичных операторам специальных символов (`&`).

### Точка с запятой (`;`)

Вы можете разместить две и более команд в одной и той же строке, разделив эти команды с помощью символа точки с запятой `;`.

Командная оболочка будет исследовать строку команды до момента достижения символа точки с запятой. Все аргументы перед этим символом точки с запятой будут рассматриваться как аргументы, не относящиеся к команде, находящейся после символа точки с запятой. Все команды с наборами аргументов будут выполнены последовательно, причем командная оболочка будет ожидать завершения исполнения каждой из команд перед исполнением следующей команды.

```sh
[paul@RHELv4u3 ~]$ echo Hello
Hello
[paul@RHELv4u3 ~]$ echo World
World
[paul@RHELv4u3 ~]$ echo Hello ; echo World
Hello
World
[paul@RHELv4u3 ~]$
```

### Амперсанд (`&`)

В том случае, если строка команды оканчивается символом амперсанда `&`, командная оболочка не будет ожидать завершения исполнения этой команды. Сразу же после ввода команды будет выведено новое приглашение командной оболочки, а сама команда будет исполняться в фоновом режиме. В момент завершения исполнения команды в фоновом режиме вы получите соответствующее сообщение.

```sh
[paul@RHELv4u3 ~]$ sleep 20 &
[1] 7925
[paul@RHELv4u3 ~]$ 
...ожидание в течение 20 секунд...
[paul@RHELv4u3 ~]$ 
[1]+  Done                     sleep 20
```

Технические подробности выполняющихся при использовании рассматриваемого оператора операций приведены в разделе, посвященном процессам.

### Символ доллара со знаком вопроса (`$?`)

Код завершения предыдущей команды сохраняется в переменной командной оболочки с именем `$?`. На самом деле `$?` является параметром командной оболочки, а не ее переменной, так как вы не можете присвоить значение переменной `$?`.

```sh
paul@debian5:~/test$ touch file1
paul@debian5:~/test$ echo $?
0
paul@debian5:~/test$ rm file1
paul@debian5:~/test$ echo $?
0
paul@debian5:~/test$ rm file1
rm: невозможно удалить "file1": Нет такого файла или каталога
paul@debian5:~/test$ echo $?
1
paul@debian5:~/test$
```

### Двойной амперсанд (`&&`)

Командная оболочка будет интерпретировать последовательность символов && как логический оператор "И". При использовании оператора && вторая команда будет исполняться только в том случае, если исполнение первой команды успешно завершится (будет возвращен нулевой код завершения).

```sh
paul@barry:~$ echo первая команда && echo вторая команда
первая команда
вторая команда
paul@barry:~$ zecho первая команда && echo вторая команда
-bash: zecho: команда не найдена...
```

Во втором примере используется тот же принцип работы логического оператора "И". Данный пример начинается с использования работоспособного варианта команды `cd` с последующим исполнением команды `ls`, после чего используется неработоспособный вариант команды `cd`, после которого команда `ls` не исполняется.

```sh
[paul@RHELv4u3 ~]$ cd gen && ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ cd gen && ls
-bash: cd: gen: Нет такого файла или каталога
```

### Двойная вертикальная черта (`||`)

Оператор `||` представляет логическую операцию "ИЛИ". Вторая команда исполняется только тогда, когда исполнение первой команды заканчивается неудачей (возвращается ненулевой код завершения).

```sh
paul@barry:~$ echo первая команда || echo вторая команда ; echo третья команда
первая команда
третья команда
paul@barry:~$ zecho первая команда || echo вторая команда ; echo третья команда
-bash: zecho: команда не найдена...
вторая команда
третья команда
paul@barry:~$
```

В следующем примере используется тот же принцип работы логического оператора "ИЛИ".

```sh
[paul@RHELv4u3 ~]$ cd gen || ls
[paul@RHELv4u3 gen]$ cd gen || ls
-bash: cd: gen: Нет такого файла или каталога
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
```

### Комбинирование операторов `&&` и `||`

Вы можете использовать описанные логические операторы "И" и "ИЛИ" для создания структур условных переходов в рамках строк команд. В данном примере используется команда `echo` для вывода информации о том, успешно ли отработала команда `rm`.

```sh
paul@laika:~/test$ rm file1 && echo Команда сработала! || echo Исполнение команды завершилось неудачей!
Команда сработала!
paul@laika:~/test$ rm file1 && echo Команда сработала! || echo Исполнение команды завершилось неудачей!
rm: невозможно удалить "file1": Нет такого файла или каталога
Исполнение команды завершилось неудачей!
paul@laika:~/test$
```

### Знак фунта (`#`)

Все написанное после символа фунта (`#`) игнорируется командной оболочкой. Это обстоятельство оказывается полезным при возникновении необходимости в написании комментариев в сценариях командной оболочки, причем комментарии ни коим образом не будут влиять на процесс исполнения команд или процесс раскрытия команд командной оболочкой.

```sh
paul@debian4:~$ mkdir test    # создаем директорию
paul@debian4:~$ cd test       #### переходим в эту директорию
paul@debian4:~/test$ ls       # пуста ли она ?
paul@debian4:~/test$
```

### Экранирование специальных символов (`\`)

Символ обратного слэша `\` позволяет использовать управляющие символы без их интерпретации командной оболочкой; процедура добавления данного символа перед управляющими символами называется экранированием символов.

```sh
[paul@RHELv4u3 ~]$ echo hello \; world
hello ; world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo экранирование \\\ \#\ \&\ \"\ \'
экранирование \ # & " '
[paul@RHELv4u3 ~]$ echo экранирование \\\?\*\"\'
экранирование \?*"'
```

### Обратный слэш в конце строки

Строка команды, заканчивающаяся обратным слэшем, продолжается в следующей строке. Командная оболочка не будет интерпретировать символы перехода на новые строки и отложит исполнение операции раскрытия команды и ее исполнение до момента чтения новой строки команды без обратного слэша в конце.

```sh
[paul@RHEL4b ~]$ echo Данная строка команды \
> разделена на три \
> части
Данная строка команды разделена на три части
[paul@RHEL4b ~]$
```

---
[Содержание](#содержание)

## 3.3 Переменные командной оболочки

### Глава 12. Переменные командной оболочки

В данной главе мы познакомимся с методикой работы с переменными окружения с использованием командной оболочки. Эти переменные обычно требуются для работы приложений.

---
[Содержание](#содержание)

## 3.4 Встраивание и параметры командных оболочек

---
[Содержание](#содержание)

## 3.5 История команд командной оболочки

---
[Содержание](#содержание)

## 3.6 Формирование списков имен файлов на основе шаблонов

---
[Содержание](#содержание)
