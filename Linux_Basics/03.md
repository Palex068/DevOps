# 3. Раскрытие команд командной оболочкой

## Содержание

+ [3.1 Команды и аргументы](#31-команды-и-аргументы)
+ [3.2 Операторы управления](#32-операторы-управления)
+ [3.3 Переменные командной оболочки](#33-переменные-командной-оболочки)
+ [3.4 Встраивание и параметры командных оболочек](#34-встраивание-и-параметры-командных-оболочек)
+ [3.5 История команд командной оболочки](#35-история-команд-командной-оболочки)
+ [3.6 Формирование списков имен файлов на основе шаблонов](#36-формирование-списков-имен-файлов-на-основе-шаблонов)

[Оглавление](./README.md)

## 3.1 Команды и аргументы

### Глава 10. Команды и аргументы

В данной главе вашему вниманию представляется обзор механизма раскрытия команд командной оболочки (`shell expansion`), созданный в ходе подробного рассмотрения методик обработки команд и аргументов. Понимание принципа работы механизма раскрытия команд командной оболочки является важным ввиду того, что многие команды в вашей системе Linux подвергаются обработке и с высокой вероятностью последующей модификации средствами командной оболочки перед исполнением.

Интерфейс командной строки системы или командная оболочка, используемая в большинстве систем Linux, носит имя `bash`, которое расшифровывается как `Bourne again shell` (название "`Born again shell`" - "возрожденная командная оболочка" было изменено с целью упоминания автора оригинальной командной оболочки `sh` Стивена Борна). Командная оболочка `bash` реализует возможности командных оболочек `sh` (оригинальная командная оболочка Стивена Борна), `csh` (командная оболочка Билла Джоя с поддержкой сценариев, синтаксис которых основан на синтаксисе языка программирования C), а также `ksh` (командная оболочка Дэвида Корна).

В данной главе для демонстрации возможностей командной оболочки будет периодически использоваться команда `echo`. Команда `echo` является достаточно простой командой: она всего лишь осуществляет вывод переданных ей данных.

```sh
paul@laika:~$ echo Burtonville
Burtonville
paul@laika:~$ echo Smurfs are blue
Smurfs are blue
```

### Аргументы

Одной из важнейших возможностей командной оболочки является возможность обработки строк команд. При вводе команды после приглашения командной оболочки и нажатии клавиши `Enter` командная оболочка приступает к обработке строки команды, разделяя ее на аргументы. При обработке строки команды командная оболочка может внести множество изменений в переданные вами аргументы.

Данный процесс называется раскрытием команд командной оболочки. После того, как командная оболочка заканчивает обработку и модификацию переданной строки команды, будет осуществляться непосредственное исполнение результирующей команды.

### Удаление пробелов

Части строки команды, которые разделены с помощью одного или нескольких последовательно расположенных символов пробелов (или табуляции), рассматриваются как отдельные аргументы, причем все пробелы удаляются. Первым аргументом является сама команда, которая должна быть исполнена, остальные аргументы передаются этой команде. Фактически командная оболочка производит разделение вашей строки команды на один или несколько аргументов.

Это полностью объясняет эквивалентность следующих четырех команд после их раскрытия средствами командной оболочки.

```sh
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
```

Команда `echo` будет выводить каждый из принятых от командной оболочки аргументов. Также команда `echo` осуществляет добавление пробелов между всеми принятыми аргументами.

### Одинарные кавычки

Вы можете предотвратить удаление пробелов из строки команды, поместив ее в одинарные кавычки. Содержимое экранированной таким образом строки рассматривается как единый аргумент. В примере ниже команда echo принимает только один аргумент.

```sh
[paul@RHEL4b ~]$ echo 'Строка с      одинарными    кавычками'
Строка с      одинарными    кавычками
[paul@RHEL4b ~]$
```

### Двойные кавычки

Вы также можете предотвратить удаление пробелов из строки команды, поместив ее в двойные кавычки. Как и в примере выше, команда `echo` примет только один аргумент.

```sh
[paul@RHEL4b ~]$ echo "Строка с      двойными    кавычками"
Строка с      двойными    кавычками
[paul@RHEL4b ~]$
```

Позднее при обсуждении переменных в рамках данной книги мы разберемся с важными различиями между одинарными и двойными кавычками.

### Команда echo и кавычки

Строки, помещенные в кавычки, могут содержать специальные обозначения символов, идентифицируемые командной `echo` (в случае использования команды `echo -e`). В примере ниже продемонстрирована методика использования обозначения символа `\n` для вставки символа переноса строки, а также обозначения символа `\t` для вставки символа табуляции (обычно эквивалентного восьми символам пробела).

```sh
[paul@RHEL4b ~]$ echo -e "Строка с \nсимволом переноса строки"
Строка с 
символом переноса строки
[paul@RHEL4b ~]$ echo -e 'Строка с \nсимволом переноса строки'
Строка с 
символом переноса строки
[paul@RHEL4b ~]$ echo -e "Строка с \tсимволом табуляции"
Строка с     символом табуляции
[paul@RHEL4b ~]$ echo -e ' Строка с \tсимволом табуляции'
Строка с     символом табуляции
[paul@RHEL4b ~]$
```

Команда `echo` может генерировать и другие символы помимо символов пробелов, табуляции и переноса строки. Обратитесь к странице руководства для ознакомления со списком допустимых обозначений символов.

### Команды

#### Внешние или встроенные команды?

Не все исполняемые командной оболочкой команды являются внешними; некоторые из них являются встроенными. Внешние команды реализованы в форме программ, представленных отдельными бинарными файлами, которые размещены в какой-либо директории файловой системы. Многие бинарные файлы, реализующие функции внешних команд, размещаются в директории `/bin` или `/sbin`. Встроенные команды являются неотъемлемой частью самого приложения командной оболочки.

#### Команда `type`

Для установления того, будет ли переданная командной оболочке команда исполнена как внешняя команда или как встроенная команда, следует использовать специальную команду `type`.

```sh
paul@laika:~$ type cd
cd is a shell builtin
paul@laika:~$ type cat
cat is /bin/cat
```

Как вы можете заметить, команда cd является встроенной, а команда `cat` - внешней.

Также вы можете использовать данную команду для установления того, является ли введенная команда псевдонимом команды.

```sh
paul@laika:~$ type ls
ls is aliased to `ls --color=auto'
```

#### Исполнение внешних команд

Некоторые команды имеют как встроенные, так и внешние реализации. В случае исполнения одной из таких команд приоритет отдается встроенной реализации. Для исполнения внешней реализации вам придется ввести полный путь к бинарному файлу, являющемуся реализацией данной команды.

```sh
paul@laika:~$ type -a echo
echo is a shell builtin
echo is /bin/echo
paul@laika:~$ /bin/echo Исполнение внешней реализации команды echo...
Исполнение внешней реализации команды echo...
```

#### Команда `which`

Команда `which` осуществляет поиск бинарных файлов в директории, заданной с помощью переменной окружения `$PATH` (переменные будут рассматриваться позднее). В примере ниже устанавливается, что `cd` является встроенной командой, а `ls`, `cp`, `rm`, `mv`, `mkdir`, `pwd` и `which` - внешними командами.

```sh
[root@RHEL4b ~]# which cp ls cd mkdir pwd 
/bin/cp
/bin/ls
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:...)
/bin/mkdir
/bin/pwd
```

### Псевдонимы команд

#### Создание псевдонима команды

Командная оболочка позволяет вам создавать псевдонимы команд (`aliases`). Псевдонимы команд обычно используются для создания лучше запоминающихся имен для существующих команд или для упрощения передачи параметров команд.

```sh
[paul@RHELv4u3 ~]$ cat count.txt 
один
два
три
[paul@RHELv4u3 ~]$ alias dog=tac
[paul@RHELv4u3 ~]$ dog count.txt 
три
два
один
```

#### Сокращения команд

Команда создания псевдонима команды (`alias`) также может оказаться полезной в случае необходимости сокращения длины имени существующей команды.

```sh
paul@laika:~$ alias ll='ls -lh --color=auto'
paul@laika:~$ alias c='clear'
paul@laika:~$
```

#### Стандартные параметры команд

Псевдонимы команд могут использоваться для передачи командам стандартных параметров. Например, ниже показана методика передачи параметра -i по умолчанию при вводе команды `rm`.

```sh
[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: удалить обычный файл "winter.txt"? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: невозможно получить доступ к winter.txt: Нет такого файла или каталога
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm:удалить пустой обычный файл "winter.txt"? no
[paul@RHELv4u3 ~]$
```

В некоторых дистрибутивах используются стандартные псевдонимы команд для защиты пользователей от случайного удаления файлов ('`rm -i`', '`mv -i`', '`cp -i`').

#### Просмотр объявлений псевдонимов команд

Вы можете передать один или несколько псевдонимов команд в качестве аргументов команды `alias` для вывода их объявлений. Исполнение команды без аргументов приведет к выводу полного списка используемых на данный момент псевдонимов.

```sh
paul@laika:~$ alias c ll
alias c='clear'
alias ll='ls -lh --color=auto'
```

#### Команда `unalias`

Также вы можете прекратить использование псевдонима команды, воспользовавшись командой `unalias`.

```sh
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$
```

### Вывод информации о раскрытии команд командной оболочкой

Вы можете активировать режим вывода информации о раскрытии команд командной оболочкой с помощью команды `set -x` и остановить вывод этой информации с помощью команды `set +x`. У вас может возникнуть потребность в использовании данной возможности как при изучении данного курса, так и в случаях, когда возникают сомнения насчет того, как командная оболочка обрабатывает переданную вами команду.

```sh
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo $USER
paul
```

---
[Содержание](#содержание)

## 3.2 Операторы управления

### Глава 11. Операторы управления

В данной главе мы будем учиться размещать более одной команды в командной строке, используя для этого операторы управления. Также мы кратко обсудим связанные с этими операторами параметры (`$?`) и вопросы использования аналогичных операторам специальных символов (`&`).

### Точка с запятой (`;`)

Вы можете разместить две и более команд в одной и той же строке, разделив эти команды с помощью символа точки с запятой `;`.

Командная оболочка будет исследовать строку команды до момента достижения символа точки с запятой. Все аргументы перед этим символом точки с запятой будут рассматриваться как аргументы, не относящиеся к команде, находящейся после символа точки с запятой. Все команды с наборами аргументов будут выполнены последовательно, причем командная оболочка будет ожидать завершения исполнения каждой из команд перед исполнением следующей команды.

```sh
[paul@RHELv4u3 ~]$ echo Hello
Hello
[paul@RHELv4u3 ~]$ echo World
World
[paul@RHELv4u3 ~]$ echo Hello ; echo World
Hello
World
[paul@RHELv4u3 ~]$
```

### Амперсанд (`&`)

В том случае, если строка команды оканчивается символом амперсанда `&`, командная оболочка не будет ожидать завершения исполнения этой команды. Сразу же после ввода команды будет выведено новое приглашение командной оболочки, а сама команда будет исполняться в фоновом режиме. В момент завершения исполнения команды в фоновом режиме вы получите соответствующее сообщение.

```sh
[paul@RHELv4u3 ~]$ sleep 20 &
[1] 7925
[paul@RHELv4u3 ~]$ 
...ожидание в течение 20 секунд...
[paul@RHELv4u3 ~]$ 
[1]+  Done                     sleep 20
```

Технические подробности выполняющихся при использовании рассматриваемого оператора операций приведены в разделе, посвященном процессам.

### Символ доллара со знаком вопроса (`$?`)

Код завершения предыдущей команды сохраняется в переменной командной оболочки с именем `$?`. На самом деле `$?` является параметром командной оболочки, а не ее переменной, так как вы не можете присвоить значение переменной `$?`.

```sh
paul@debian5:~/test$ touch file1
paul@debian5:~/test$ echo $?
0
paul@debian5:~/test$ rm file1
paul@debian5:~/test$ echo $?
0
paul@debian5:~/test$ rm file1
rm: невозможно удалить "file1": Нет такого файла или каталога
paul@debian5:~/test$ echo $?
1
paul@debian5:~/test$
```

### Двойной амперсанд (`&&`)

Командная оболочка будет интерпретировать последовательность символов && как логический оператор "И". При использовании оператора && вторая команда будет исполняться только в том случае, если исполнение первой команды успешно завершится (будет возвращен нулевой код завершения).

```sh
paul@barry:~$ echo первая команда && echo вторая команда
первая команда
вторая команда
paul@barry:~$ zecho первая команда && echo вторая команда
-bash: zecho: команда не найдена...
```

Во втором примере используется тот же принцип работы логического оператора "И". Данный пример начинается с использования работоспособного варианта команды `cd` с последующим исполнением команды `ls`, после чего используется неработоспособный вариант команды `cd`, после которого команда `ls` не исполняется.

```sh
[paul@RHELv4u3 ~]$ cd gen && ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ cd gen && ls
-bash: cd: gen: Нет такого файла или каталога
```

### Двойная вертикальная черта (`||`)

Оператор `||` представляет логическую операцию "ИЛИ". Вторая команда исполняется только тогда, когда исполнение первой команды заканчивается неудачей (возвращается ненулевой код завершения).

```sh
paul@barry:~$ echo первая команда || echo вторая команда ; echo третья команда
первая команда
третья команда
paul@barry:~$ zecho первая команда || echo вторая команда ; echo третья команда
-bash: zecho: команда не найдена...
вторая команда
третья команда
paul@barry:~$
```

В следующем примере используется тот же принцип работы логического оператора "ИЛИ".

```sh
[paul@RHELv4u3 ~]$ cd gen || ls
[paul@RHELv4u3 gen]$ cd gen || ls
-bash: cd: gen: Нет такого файла или каталога
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
```

### Комбинирование операторов `&&` и `||`

Вы можете использовать описанные логические операторы "И" и "ИЛИ" для создания структур условных переходов в рамках строк команд. В данном примере используется команда `echo` для вывода информации о том, успешно ли отработала команда `rm`.

```sh
paul@laika:~/test$ rm file1 && echo Команда сработала! || echo Исполнение команды завершилось неудачей!
Команда сработала!
paul@laika:~/test$ rm file1 && echo Команда сработала! || echo Исполнение команды завершилось неудачей!
rm: невозможно удалить "file1": Нет такого файла или каталога
Исполнение команды завершилось неудачей!
paul@laika:~/test$
```

### Знак фунта (`#`)

Все написанное после символа фунта (`#`) игнорируется командной оболочкой. Это обстоятельство оказывается полезным при возникновении необходимости в написании комментариев в сценариях командной оболочки, причем комментарии ни коим образом не будут влиять на процесс исполнения команд или процесс раскрытия команд командной оболочкой.

```sh
paul@debian4:~$ mkdir test    # создаем директорию
paul@debian4:~$ cd test       #### переходим в эту директорию
paul@debian4:~/test$ ls       # пуста ли она ?
paul@debian4:~/test$
```

### Экранирование специальных символов (`\`)

Символ обратного слэша `\` позволяет использовать управляющие символы без их интерпретации командной оболочкой; процедура добавления данного символа перед управляющими символами называется экранированием символов.

```sh
[paul@RHELv4u3 ~]$ echo hello \; world
hello ; world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo экранирование \\\ \#\ \&\ \"\ \'
экранирование \ # & " '
[paul@RHELv4u3 ~]$ echo экранирование \\\?\*\"\'
экранирование \?*"'
```

### Обратный слэш в конце строки

Строка команды, заканчивающаяся обратным слэшем, продолжается в следующей строке. Командная оболочка не будет интерпретировать символы перехода на новые строки и отложит исполнение операции раскрытия команды и ее исполнение до момента чтения новой строки команды без обратного слэша в конце.

```sh
[paul@RHEL4b ~]$ echo Данная строка команды \
> разделена на три \
> части
Данная строка команды разделена на три части
[paul@RHEL4b ~]$
```

---
[Содержание](#содержание)

## 3.3 Переменные командной оболочки

### Глава 12. Переменные командной оболочки

В данной главе мы познакомимся с методикой работы с переменными окружения с использованием командной оболочки. Эти переменные обычно требуются для работы приложений.

### Символ доллара ($)

Еще одним важным интерпретируемым командной оболочкой символом является символ доллара `$`. Командная оболочка будет искать переменную окружения с именем, соответствующим размещенной после символа доллара строке, и заменять данный символ и имя переменной на значение этой переменной (или ни на что в том случае, если переменной не существует).

Ниже приведено несколько примеров использования переменных

```sh
$HOSTNAME, $USER, $UID, $SHELL и $HOME
[paul@RHELv4u3 ~]$ echo Это командная оболочка $SHELL
Это командная оболочка /bin/bash
[paul@RHELv4u3 ~]$ echo Данная командная оболочка $SHELL используется на компьютере $HOSTNAME
Данная командная оболочка /bin/bash используется на компьютере RHELv4u3.localdomain
[paul@RHELv4u3 ~]$ echo Идентификатор пользователя $USER равен $UID
Идентификатор пользователя paul равен 500
[paul@RHELv4u3 ~]$ echo Моей домашней директорией является директория $HOME
Моей домашней директорией является директория /home/paul
```

### Зависимость от регистра

В данном примере показано, что имена переменных командной оболочки зависят от регистра!

```sh
[paul@RHELv4u3 ~]$ echo Привет $USER
Привет paul
[paul@RHELv4u3 ~]$ echo Привет $user
Привет
```

### Создание переменных

В данном примере осуществляется создание переменной `$MyVar` с последующей установкой ее значения. После этого в примере используется команда `echo` для проверки значения созданной переменной.

```sh
[paul@RHELv4u3 gen]$ MyVar=555
[paul@RHELv4u3 gen]$ echo $MyVar
555
[paul@RHELv4u3 gen]$
```

### Кавычки

Обратите внимание на то, что двойные кавычки также позволяют осуществлять раскрытие переменных в строке команды, в то время, как одинарные кавычки позволяют предотвратить такое раскрытие.

```sh
[paul@RHELv4u3 ~]$ MyVar=555
[paul@RHELv4u3 ~]$ echo $MyVar
555
[paul@RHELv4u3 ~]$ echo "$MyVar"
555
[paul@RHELv4u3 ~]$ echo '$MyVar'
$MyVar
```

Командная оболочка `bash` будет заменять переменные на их значения в строках, помещенных в двойные кавычки, но не будет осуществлять такую замену в строках, помещенных в одинарные кавычки.

```sh
paul@laika:~$ city=Burtonville
paul@laika:~$ echo "Сейчас мы находимся в городе $city."
Сейчас мы находимся в городе Burtonville.
paul@laika:~$ echo ' Сейчас мы находимся в городе $city.'
Сейчас мы находимся в городе $city.
```

### Команда `set`

Вы можете использовать команду `set` для вывода списка переменных окружения. В системах Ubuntu и Debian команда `set` также выведет список функций командной оболочки после списка переменных командной оболочки. Поэтому для ознакомления со всеми элементами списка переменных окружения при работе с данными системами рекомендуется использовать команду `set | more`.

### Команда `unset`

Следует использовать команду `unset` для удаления переменной из вашего окружения командной оболочки.

```sh
[paul@RHEL4b ~]$ MyVar=8472
[paul@RHEL4b ~]$ echo $MyVar
8472
[paul@RHEL4b ~]$ unset MyVar
[paul@RHEL4b ~]$ echo $MyVar

[paul@RHEL4b ~]$
```

### Переменная окружения `$PS1`

Переменная окружения `$PS1` устанавливает формат приветствия вашей командной оболочки. При вводе строки форматирования вы можете использовать обратный слэш для экранирования таких специальных символов, как символ `\u`, предназначенный для вывода имени пользователя, или `\w`, предназначенный для вывода имени рабочей директории. На странице руководства командной оболочки `bash` представлен полный список специальных символов.

В примере ниже мы несколько раз изменяем значение переменной окружения `$PS1`.

```sh
paul@deb503:~$ PS1=приглашение
приглашение
приглашениеPS1='приглашение '
приглашение 
приглашение PS1='> '
> 
> PS1='\u@\h$ '
paul@deb503$ 
paul@deb503$ PS1='\u@\h:\W$'
paul@deb503:~$
```

Для того, чтобы избежать неисправимых ошибок, вы можете использовать зеленый цвет для приглашений командной оболочки, выводимых обычным пользователям, и красный цвет для приглашений командной оболочки, выводимых пользователю `root`. Добавьте следующие строки в ваш файл `.bashrc` для использования зеленого цвета в приглашениях, выводимых обычным пользователям.

```sh
# цветное приглашение командной оболочки, созданное paul
RED='\[\033[01;31m\]'
WHITE='\[\033[01;00m\]'
GREEN='\[\033[01;32m\]'
BLUE='\[\033[01;34m\]'
export PS1="${debian_chroot:+($debian_chroot)}$GREEN\u$WHITE@$BLUE\h$WHITE\w\$ "
```

### Переменная окружения `$PATH`

Переменная окружения `$PATH` устанавливает директории файловой системы, в которых командная оболочка ищет бинарные файлы, необходимые для исполнения команд (за исключением тех случаев, когда команда является встроенной или представлена псевдонимом команды). Данная переменная содержит список путей к директориям с символами двоеточия в качестве разделителей.

```sh
[[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:
```

Командная оболочка не будет осуществлять поиск бинарных файлов, которые могут быть исполнены, в текущей директории. (Функция поиска исполняемых файлов в текущей директории являлась простейшим механизмом несанкционированного доступа к данным, хранящимся на компьютерах под управлением PC-DOS). В том случае, если вы хотите, чтобы командная оболочка осуществляла поиск исполняемых файлов в текущей директории, вам следует добавить символ . в конец строки, являющейся значением переменной `$PATH` вашей командной оболочки.

```sh
[paul@RHEL4b ~]$ PATH=$PATH:.
[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:.
[paul@RHEL4b ~]$
```

Значение переменной `$PATH` вашей командной оболочки может отличаться в случае использования команды `su` вместо команды `su -`, так как последняя команда позволяет дополнительно использовать значения переменных окружения целевого пользователя. К примеру, в представленный значением переменной `$PATH` список директорий пользователя `root` обычно добавляются директории `/sbin`.

```sh
[paul@RHEL3 ~]$ su
Password: 
[root@RHEL3 paul]# echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin
[root@RHEL3 paul]# exit
[paul@RHEL3 ~]$ su -
Password: 
[root@RHEL3 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:
[root@RHEL3 ~]#
```

### Команда `env`

Команда `env` в случае использования без параметров выведет список экспортированных переменных окружения. Отличие данной команды от команды `set` с параметрами заключается в том, что команда `set` выводит список всех переменных окружения, включая те переменные, которые не экспортируются в дочерние командные оболочки.

Кроме того, команда env может также использоваться для запуска "чистой" командной оболочки (командной оболочки без наследования какого-либо окружения). Команда `env -i` позволяет очистить окружение дочерней командной оболочки.

При рассмотрении данного примера следует обратить внимание на то, что командная оболочка `bash` установит значение переменной окружения `$SHELL` при запуске.

```sh
[paul@RHEL4b ~]$ bash -c 'echo $SHELL $HOME $USER'
/bin/bash /home/paul paul
[paul@RHEL4b ~]$ env -i bash -c 'echo $SHELL $HOME $USER'
/bin/bash
[paul@RHEL4b ~]$
```

Вы можете использовать команду `env` для установки значения переменной `$LANG` или любой другой переменной окружения одного экземпляра командной оболочки `bash` в рамках одной команды. В примере ниже данная возможность используется для демонстрации влияния значения переменной `$LANG` на работу механизма поиска файлов по шаблонам (для получения дополнительной информации о данном механизме следует обратиться к главе, посвященной поиску файлов по шаблонам).

```sh
[paul@RHEL4b test]$ env LANG=C bash -c 'ls File[a-z]'
Filea  Fileb
[paul@RHEL4b test]$ env LANG=en_US.UTF-8 bash -c 'ls File[a-z]'
Filea  FileA  Fileb  FileB
[paul@RHEL4b test]$
```

### Команда `export`

Вы можете экспортировать переменные командной оболочки в другие командные оболочки с помощью команды `export`. В примере ниже с помощью данной команды осуществляется экспорт переменной окружения в дочерние командные оболочки.

```sh
[paul@RHEL4b ~]$ var3=три
[paul@RHEL4b ~]$ var4=четыре
[paul@RHEL4b ~]$ export var4
[paul@RHEL4b ~]$ echo $var3 $var4
три четыре
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $var3 $var4
четыре
```

При этом с помощью данной команды переменная не экспортируется в родительскую командную оболочку (ниже приведено продолжение предыдущего примера).

```sh
[paul@RHEL4b ~]$ export var5=пять
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
четыре пять
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
три четыре
[paul@RHEL4b ~]$
```

### Разграничения переменных

До текущего момента мы сталкивались с тем, что командная оболочка `bash` интерпретирует переменную начиная с символа доллара, продолжая интерпретацию до появления первого не алфавитно-цифрового символа, который не является символом подчеркивания. В некоторых ситуациях такое поведение может оказаться проблемой. Для решения этой проблемы могут использоваться фигурные скобки таким образом, как показано в примере ниже.

```sh
[paul@RHEL4b ~]$ prefix=Super
[paul@RHEL4b ~]$ echo Привет $prefixman и $prefixgirl
Привет  и
[paul@RHEL4b ~]$ echo Привет ${prefix}man и ${prefix}girl
Привет Superman и Supergirl
[paul@RHEL4b ~]$
```

### Несвязанные переменные

В примере ниже представлена попытка вывода значения переменной `$MyVar`, но она не является успешной ввиду того, что переменной не существует. По умолчанию командная оболочка не будет выводить ничего в том случае, если переменная не связана (ее не существует).

```sh
[paul@RHELv4u3 gen]$ echo $MyVar

[paul@RHELv4u3 gen]$
```

Однако, существует параметр командной оболочки `nounset`, который вы можете использовать для генерации ошибки в том случае, если используемой переменной не существует.

```sh
paul@laika:~$ set -u
paul@laika:~$ echo $Myvar
bash: Myvar: unbound variable
paul@laika:~$ set +u
paul@laika:~$ echo $Myvar

paul@laika:~$
```

В командной оболочке `bash` команда `set -u` идентична команде `set -o nounset` и, по аналогии, команда `set +u` идентична команде `set +o nounset`.

---
[Содержание](#содержание)

## 3.4 Встраивание и параметры командных оболочек

---
[Содержание](#содержание)

## 3.5 История команд командной оболочки

---
[Содержание](#содержание)

## 3.6 Формирование списков имен файлов на основе шаблонов

---
[Содержание](#содержание)
